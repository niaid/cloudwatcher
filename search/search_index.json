{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"cloudwatcher cloudwatcher is a tool for monitoring AWS CloudWatch metrics and logs. It can be used both as a command line tool and as a Python library. Quick start Here are the steps to use cloudwatcher as a command line tool: Install cloudwatcher with pip Configure target EC2 instance (optional if used with ECS ContainerInsights) Run cloudwatcher CLI or Python API Documentation Full package documentation, which includes examples of usage and setup, can be found at: https://niaid.github.io/cloudwatcher . Authors Micha\u0142 Stolarczyk","title":"Home"},{"location":"#cloudwatcher","text":"cloudwatcher is a tool for monitoring AWS CloudWatch metrics and logs. It can be used both as a command line tool and as a Python library.","title":"cloudwatcher"},{"location":"#quick-start","text":"Here are the steps to use cloudwatcher as a command line tool: Install cloudwatcher with pip Configure target EC2 instance (optional if used with ECS ContainerInsights) Run cloudwatcher CLI or Python API","title":"Quick start"},{"location":"#documentation","text":"Full package documentation, which includes examples of usage and setup, can be found at: https://niaid.github.io/cloudwatcher .","title":"Documentation"},{"location":"#authors","text":"Micha\u0142 Stolarczyk","title":"Authors"},{"location":"API_documentation/","text":"API documentation CloudWatcher A base class for CloudWatch managers Source code in cloudwatcher/cloudwatcher.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class CloudWatcher : \"\"\" A base class for CloudWatch managers \"\"\" def __init__ ( self , service_name : str , aws_region_name : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , ) -> None : \"\"\" Initialize CloudWatcher Args: service_name (str): The name of the service to use aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None \"\"\" self . aws_region_name = aws_region_name or \"us-east-1\" self . service_name = service_name self . client : boto3 . Session . client = boto3 . client ( service_name = self . service_name , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , ) __init__ ( service_name , aws_region_name = None , aws_access_key_id = None , aws_secret_access_key = None , aws_session_token = None ) Initialize CloudWatcher Parameters: Name Type Description Default service_name str The name of the service to use required aws_region_name Optional [ str ] The AWS region name. Defaults to 'us-east-1' None aws_access_key_id Optional [ str ] The AWS access key ID. Defaults to None None aws_secret_access_key Optional [ str ] The AWS secret access key. Defaults to None None aws_session_token Optional [ str ] The AWS session token. Defaults to None None Source code in cloudwatcher/cloudwatcher.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , service_name : str , aws_region_name : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , ) -> None : \"\"\" Initialize CloudWatcher Args: service_name (str): The name of the service to use aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None \"\"\" self . aws_region_name = aws_region_name or \"us-east-1\" self . service_name = service_name self . client : boto3 . Session . client = boto3 . client ( service_name = self . service_name , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , ) LogWatcher Bases: CloudWatcher A class for AWS CloudWatch log events retrieval and parsing Source code in cloudwatcher/logwatcher.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class LogWatcher ( CloudWatcher ): \"\"\" A class for AWS CloudWatch log events retrieval and parsing \"\"\" def __init__ ( self , log_group_name : str , log_stream_name : str , start_token : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize LogWatcher Args: log_group_name (str): The name of the log group log_stream_name (str): The name of the log stream start_token (Optional[str]): The token to use for the next query. Defaults to None aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' \"\"\" super () . __init__ ( service_name = \"logs\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . log_group_name = log_group_name self . log_stream_name = log_stream_name self . start_token = start_token def __repr__ ( self ) -> str : \"\"\" Return a string representation of the object Returns: str: The string representation of the object \"\"\" return f \"LogWatcher(' { self . log_group_name } / { self . log_stream_name } ')\" def check_log_exists ( self ) -> bool : \"\"\" Check if the log stream exists Returns: bool: True if the log stream exists, False otherwise \"\"\" try : response = self . client . describe_log_streams ( logGroupName = self . log_group_name , logStreamNamePrefix = self . log_stream_name , ) return True if response [ \"logStreams\" ] else False except Exception as e : _LOGGER . error ( f \"Error checking if log stream exists: { e } \" ) return False def _get_events ( self , query_kwargs : Dict [ str , Any ]) -> List [ Event ]: \"\"\" Get events from CloudWatch and update the arguments for the next query with 'nextForwardToken' Args: query_kwargs (Dict[str, Any]): The query arguments Returns: List[Event]: The list of log events \"\"\" response = self . client . get_log_events ( ** query_kwargs ) query_kwargs . update ({ \"nextToken\" : response [ \"nextForwardToken\" ]}) return response [ \"events\" ], response [ \"nextForwardToken\" ] def stream_cloudwatch_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> List [ Event ]: \"\"\" A generator that retrieves desired number of log events per iteration Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: List[Event]: The list of log events \"\"\" query_kwargs = dict ( logGroupName = self . log_group_name , logStreamName = self . log_stream_name , limit = events_limit , startFromHead = True , ) if self . start_token : query_kwargs . update ({ \"nextToken\" : self . start_token }) _LOGGER . debug ( f \"Retrieving log events from: { self . log_group_name } / { self . log_stream_name } \" ) events , token = self . _get_events ( query_kwargs ) yield events , token while events : events , token = self . _get_events ( query_kwargs ) retry_attempts = 0 while not events and max_retry_attempts > retry_attempts : events , token = self . _get_events ( query_kwargs ) retry_attempts += 1 _LOGGER . debug ( f \"Received empty log events list. Retry attempt: { retry_attempts } \" ) yield events , token def stream_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 , sep : str = \"<br>\" , ) -> Tuple [ List [ str ], str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. sep (str): The separator to use between log events. Returns: Tuple[List[str], str]: The list of formatted log events and the next token \"\"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts , ): yield sep . join ( self . format_logs_events ( log_events = events )), token def return_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> Tuple [ str , str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: Tuple[str, str]: The list of formatted log events and the next token \"\"\" formatted_events = \"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts ): formatted_events += \" \\n \" . join ( self . format_logs_events ( log_events = events )) return formatted_events , token def format_logs_events ( self , log_events : List [ Event ], regex : str = r \"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\" , fmt_str : str = \"[ {time} UTC] {message} \" , ) -> List [ str ]: \"\"\" Format log events Args: log_events (List[Event]): The list of log events. regex (str): The regex to use to extract the time and message. fmt_str (str): The format string to use to format the time and message. \"\"\" def _datestr ( timestamp : int , fmt_str : str = \" %d -%m-%Y %H:%M:%S\" ) -> str : \"\"\" Convert milliseconds after Jan 1, 1970 UTC to a string date repr Args: timestamp (int): milliseconds after Jan 1, 1970 UTC fmt_str (str): format string for the date Returns: str: date string \"\"\" return datetime . fromtimestamp ( timestamp / 1000.0 ) . strftime ( fmt_str ) formatted_log_list = [] for e in log_events : m = re . search ( regex , e [ \"message\" ]) msg = e [ \"message\" ][ m . end () :] if m else e [ \"message\" ] formatted_log_list . append ( fmt_str . format ( time = _datestr ( e [ \"timestamp\" ]), message = msg . strip ()) ) return formatted_log_list def save_log_file ( self , file_path : str ) -> None : \"\"\" Save the log file to the specified path Args: file_path (str): The path to save the log file to. \"\"\" logs , _ = self . return_formatted_logs () with open ( file_path , \"w\" ) as f : f . write ( logs ) _LOGGER . info ( f \"Logs ' { self . log_group_name } / { self . log_stream_name } ' saved to: { file_path } \" ) __init__ ( log_group_name , log_stream_name , start_token = None , aws_access_key_id = None , aws_secret_access_key = None , aws_session_token = None , aws_region_name = None ) Initialize LogWatcher Parameters: Name Type Description Default log_group_name str The name of the log group required log_stream_name str The name of the log stream required start_token Optional [ str ] The token to use for the next query. Defaults to None None aws_access_key_id Optional [ str ] The AWS access key ID. Defaults to None None aws_secret_access_key Optional [ str ] The AWS secret access key. Defaults to None None aws_session_token Optional [ str ] The AWS session token. Defaults to None None aws_region_name Optional [ str ] The AWS region name. Defaults to 'us-east-1' None Source code in cloudwatcher/logwatcher.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , log_group_name : str , log_stream_name : str , start_token : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize LogWatcher Args: log_group_name (str): The name of the log group log_stream_name (str): The name of the log stream start_token (Optional[str]): The token to use for the next query. Defaults to None aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' \"\"\" super () . __init__ ( service_name = \"logs\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . log_group_name = log_group_name self . log_stream_name = log_stream_name self . start_token = start_token __repr__ () Return a string representation of the object Returns: Name Type Description str str The string representation of the object Source code in cloudwatcher/logwatcher.py 53 54 55 56 57 58 59 60 def __repr__ ( self ) -> str : \"\"\" Return a string representation of the object Returns: str: The string representation of the object \"\"\" return f \"LogWatcher(' { self . log_group_name } / { self . log_stream_name } ')\" check_log_exists () Check if the log stream exists Returns: Name Type Description bool bool True if the log stream exists, False otherwise Source code in cloudwatcher/logwatcher.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def check_log_exists ( self ) -> bool : \"\"\" Check if the log stream exists Returns: bool: True if the log stream exists, False otherwise \"\"\" try : response = self . client . describe_log_streams ( logGroupName = self . log_group_name , logStreamNamePrefix = self . log_stream_name , ) return True if response [ \"logStreams\" ] else False except Exception as e : _LOGGER . error ( f \"Error checking if log stream exists: { e } \" ) return False format_logs_events ( log_events , regex = '^ \\\\ [ \\\\ d+- \\\\ d+- \\\\ d+ \\\\ s \\\\ d+: \\\\ d+: \\\\ d+(.|,) \\\\ d+( \\\\ ]| \\\\ s- \\\\ s \\\\ w+ \\\\ ])' , fmt_str = '[ {time} UTC] {message} ' ) Format log events Parameters: Name Type Description Default log_events List [ Event ] The list of log events. required regex str The regex to use to extract the time and message. '^\\\\[\\\\d+-\\\\d+-\\\\d+\\\\s\\\\d+:\\\\d+:\\\\d+(.|,)\\\\d+(\\\\]|\\\\s-\\\\s\\\\w+\\\\])' fmt_str str The format string to use to format the time and message. '[{time} UTC] {message}' Source code in cloudwatcher/logwatcher.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def format_logs_events ( self , log_events : List [ Event ], regex : str = r \"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\" , fmt_str : str = \"[ {time} UTC] {message} \" , ) -> List [ str ]: \"\"\" Format log events Args: log_events (List[Event]): The list of log events. regex (str): The regex to use to extract the time and message. fmt_str (str): The format string to use to format the time and message. \"\"\" def _datestr ( timestamp : int , fmt_str : str = \" %d -%m-%Y %H:%M:%S\" ) -> str : \"\"\" Convert milliseconds after Jan 1, 1970 UTC to a string date repr Args: timestamp (int): milliseconds after Jan 1, 1970 UTC fmt_str (str): format string for the date Returns: str: date string \"\"\" return datetime . fromtimestamp ( timestamp / 1000.0 ) . strftime ( fmt_str ) formatted_log_list = [] for e in log_events : m = re . search ( regex , e [ \"message\" ]) msg = e [ \"message\" ][ m . end () :] if m else e [ \"message\" ] formatted_log_list . append ( fmt_str . format ( time = _datestr ( e [ \"timestamp\" ]), message = msg . strip ()) ) return formatted_log_list return_formatted_logs ( events_limit = 1000 , max_retry_attempts = 5 ) A generator that yields formatted log events Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 Returns: Type Description Tuple [ str , str ] Tuple[str, str]: The list of formatted log events and the next token Source code in cloudwatcher/logwatcher.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def return_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> Tuple [ str , str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: Tuple[str, str]: The list of formatted log events and the next token \"\"\" formatted_events = \"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts ): formatted_events += \" \\n \" . join ( self . format_logs_events ( log_events = events )) return formatted_events , token save_log_file ( file_path ) Save the log file to the specified path Parameters: Name Type Description Default file_path str The path to save the log file to. required Source code in cloudwatcher/logwatcher.py 206 207 208 209 210 211 212 213 214 215 216 217 218 def save_log_file ( self , file_path : str ) -> None : \"\"\" Save the log file to the specified path Args: file_path (str): The path to save the log file to. \"\"\" logs , _ = self . return_formatted_logs () with open ( file_path , \"w\" ) as f : f . write ( logs ) _LOGGER . info ( f \"Logs ' { self . log_group_name } / { self . log_stream_name } ' saved to: { file_path } \" ) stream_cloudwatch_logs ( events_limit = 1000 , max_retry_attempts = 5 ) A generator that retrieves desired number of log events per iteration Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 Returns: Type Description List [ Event ] List[Event]: The list of log events Source code in cloudwatcher/logwatcher.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def stream_cloudwatch_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> List [ Event ]: \"\"\" A generator that retrieves desired number of log events per iteration Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: List[Event]: The list of log events \"\"\" query_kwargs = dict ( logGroupName = self . log_group_name , logStreamName = self . log_stream_name , limit = events_limit , startFromHead = True , ) if self . start_token : query_kwargs . update ({ \"nextToken\" : self . start_token }) _LOGGER . debug ( f \"Retrieving log events from: { self . log_group_name } / { self . log_stream_name } \" ) events , token = self . _get_events ( query_kwargs ) yield events , token while events : events , token = self . _get_events ( query_kwargs ) retry_attempts = 0 while not events and max_retry_attempts > retry_attempts : events , token = self . _get_events ( query_kwargs ) retry_attempts += 1 _LOGGER . debug ( f \"Received empty log events list. Retry attempt: { retry_attempts } \" ) yield events , token stream_formatted_logs ( events_limit = 1000 , max_retry_attempts = 5 , sep = '<br>' ) A generator that yields formatted log events Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 sep str The separator to use between log events. '<br>' Returns: Type Description Tuple [ List [ str ], str ] Tuple[List[str], str]: The list of formatted log events and the next token Source code in cloudwatcher/logwatcher.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def stream_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 , sep : str = \"<br>\" , ) -> Tuple [ List [ str ], str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. sep (str): The separator to use between log events. Returns: Tuple[List[str], str]: The list of formatted log events and the next token \"\"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts , ): yield sep . join ( self . format_logs_events ( log_events = events )), token MetricWatcher Bases: CloudWatcher A class for AWS CloudWatch metric retrieval and parsing Source code in cloudwatcher/metricwatcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 class MetricWatcher ( CloudWatcher ): \"\"\" A class for AWS CloudWatch metric retrieval and parsing \"\"\" def __init__ ( self , namespace : str , dimensions_list : List [ Dict [ str , str ]], metric_name : str , metric_id : str , metric_unit : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize MetricWatcher Args: namespace (str): the namespace of the metric dimensions_list (List[Dict[str, str]]): the dimensions of the metric metric_name (str): the name of the metric metric_id (str): the ID of the metric metric_unit (Optional[str]): the unit of the metric aws_access_key_id (Optional[str]): the AWS access key ID aws_secret_access_key (Optional[str]): the AWS secret access key aws_session_token (Optional[str]): the AWS session token aws_region_name (Optional[str]): the AWS region name \"\"\" super () . __init__ ( service_name = \"cloudwatch\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . namespace = namespace self . dimensions_list = dimensions_list self . metric_name = metric_name self . metric_id = metric_id self . metric_unit = metric_unit self . ec2_resource = boto3 . resource ( service_name = \"ec2\" , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , ) def query_ec2_metrics ( self , days : int , hours : int , minutes : int , stat : str , period : int , ) -> Dict : \"\"\" Query EC2 metrics Args: days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time stat (str): the statistic to query period (int): the period of the metric Returns: Dict: the response from the query, check the structure of the response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501 \"\"\" # Create CloudWatch client now = datetime . datetime . now ( pytz . utc ) start_time = now - datetime . timedelta ( days = days , hours = hours , minutes = minutes ) _time = lambda x : x . strftime ( \"%Y-%m- %d %H:%M:%S\" ) _LOGGER . info ( f \"Querying ' { self . metric_name } ' for dimensions { self . dimensions_list } \" f \"from { _time ( start_time ) } to { _time ( now ) } \" ) response = self . client . get_metric_data ( MetricDataQueries = [ { \"Id\" : self . metric_id , \"MetricStat\" : { \"Metric\" : { \"Namespace\" : self . namespace , \"MetricName\" : self . metric_name , \"Dimensions\" : [ dim . dict () for dim in self . dimensions_list ], }, \"Stat\" : stat , \"Unit\" : str ( self . metric_unit ), # str(None) is desired, if no unit is specified \"Period\" : period , }, }, ], StartTime = start_time , EndTime = now , ) resp_status = response [ \"ResponseMetadata\" ][ \"HTTPStatusCode\" ] if resp_status != 200 : _LOGGER . error ( f \"Invalid response status code: { resp_status } \" ) return _LOGGER . debug ( f \"Response status code: { resp_status } \" ) return response def get_ec2_uptime ( self , ec2_instance_id : str , days : int , hours : int , minutes : int , ) -> int : \"\"\" Get the runtime of an EC2 instance Args: ec2_instance_id (str): the ID of the EC2 instance days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time Returns: int: the runtime of the EC2 instance in minutes \"\"\" if not self . is_ec2_running ( ec2_instance_id ): _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is not running anymore. \" f \"Uptime will be estimated based on reported metrics in \" f \"the last { days } days\" ) instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) # get the latest reported metric metrics_response = self . query_ec2_metrics ( days = days , hours = hours , minutes = minutes , stat = \"Maximum\" , # any stat works period = 60 , # most precise period that AWS stores for instances where # start time is between 3 hours and 15 days ago ) # extract the latest metric report time timed_metrics = self . timed_metric_factory ( metrics_response ) try : earliest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ 0 ] latest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ - 1 ] return ( earliest_metric_report_time - latest_metric_report_time ) . total_seconds () except IndexError : _LOGGER . warning ( f \"No metric data found for EC2: { self . dimension_value } \" ) return instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) for instance in instances : _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is still running. \" f \"Launch time: { instance . launch_time } \" ) return ( datetime . now ( pytz . utc ) - instance . launch_time ) . total_seconds () def is_ec2_running ( self , ec2_instance_id : str ) -> bool : \"\"\" Check if EC2 instance is running Args: ec2_instance_id (str): the ID of the EC2 instance Returns: bool: True if EC2 instance is running, False otherwise \"\"\" instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ ec2_instance_id ]}] ) if len ( list ( instances )) == 0 : return None if len ( list ( instances )) > 1 : raise Exception ( f \"Multiple EC2 instances matched by ID: { ec2_instance_id } \" ) for instance in instances : # check the status codes and their meanings: # https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501 if instance . state [ \"Code\" ] <= 16 : return True return False @staticmethod def timed_metric_factory ( response : dict ) -> List [ TimedMetric ]: \"\"\" Create a collection of TimedMetrics from the CloudWatch client response. Args: response (dict): the response from the query Returns: List[TimedMetric]: a collection of TimedMetrics \"\"\" return [ TimedMetric ( label = metric_data_result [ \"Label\" ], timestamps = metric_data_result [ \"Timestamps\" ], values = metric_data_result [ \"Values\" ], ) for metric_data_result in response [ \"MetricDataResults\" ] ] def _exec_timed_metric_handler ( self , handler_class : TimedMetricHandler , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ** kwargs , ) -> None : \"\"\" Internal method to execute a TimedMetricHandler Args: handler_class (TimedMetricHandler): the TimedMetricHandler to execute response (Optional[Dict]): the response from the query query_kwargs (Optional[Dict]): the query kwargs to use for the query **kwargs: additional kwargs to pass to the handler \"\"\" _LOGGER . debug ( f \"Executing ' { handler_class . __name__ } '\" ) response = response or self . query_ec2_metrics ( ** query_kwargs ) timed_metrics = self . timed_metric_factory ( response ) for timed_metric in timed_metrics : if len ( timed_metric . values ) < 1 : continue handler = handler_class ( timed_metric = timed_metric ) handler ( ** kwargs ) def _exec_response_handler ( self , handler_class : ResponseHandler , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ** kwargs , ) -> None : \"\"\" Internal method to execute a ResponseHandler Args: handler_class (ResponseHandler): the ResponseHandler to execute response (Optional[Dict]): the response from the query query_kwargs (Optional[Dict]): the query kwargs to use for the query **kwargs: additional kwargs to pass to the handler \"\"\" _LOGGER . debug ( f \"Executing ' { handler_class . __name__ } '\" ) response = response or self . query_ec2_metrics ( ** query_kwargs ) handler = handler_class ( response = response ) handler ( ** kwargs ) def save_metric_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a JSON file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricJsonSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def save_metric_csv ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a CSV file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricCsvSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def log_metric ( self , response : Optional [ Dict ] = None , query_preset : Optional [ str ] = None ): \"\"\" Query and log the metric data Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricLogger , target = None , # TODO: add support for saving to file response = response , ) def save_metric_plot ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and plot the metric data Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricPlotter , target = file_path , metric_unit = self . metric_unit , response = response , query_kwargs = query_kwargs , ) def log_metric_summary ( self , response : Optional [ Dict ] = None ): \"\"\" Query and summarize the metric data to a JSON file Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricSummarizer , target = None , # TODO: add support for saving to file metric_unit = self . metric_unit , summarizer = ( \"Max\" , max ), response = response , ) def save_response_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the response data to a JSON file Args: file_path (str): the file path to save the response data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def log_response ( self , response : Optional [ Dict ] = None ): \"\"\" Query and log the response Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseLogger , target = None , response = response , ) __init__ ( namespace , dimensions_list , metric_name , metric_id , metric_unit = None , aws_access_key_id = None , aws_secret_access_key = None , aws_session_token = None , aws_region_name = None ) Initialize MetricWatcher Parameters: Name Type Description Default namespace str the namespace of the metric required dimensions_list List [ Dict [ str , str ]] the dimensions of the metric required metric_name str the name of the metric required metric_id str the ID of the metric required metric_unit Optional [ str ] the unit of the metric None aws_access_key_id Optional [ str ] the AWS access key ID None aws_secret_access_key Optional [ str ] the AWS secret access key None aws_session_token Optional [ str ] the AWS session token None aws_region_name Optional [ str ] the AWS region name None Source code in cloudwatcher/metricwatcher.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , namespace : str , dimensions_list : List [ Dict [ str , str ]], metric_name : str , metric_id : str , metric_unit : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize MetricWatcher Args: namespace (str): the namespace of the metric dimensions_list (List[Dict[str, str]]): the dimensions of the metric metric_name (str): the name of the metric metric_id (str): the ID of the metric metric_unit (Optional[str]): the unit of the metric aws_access_key_id (Optional[str]): the AWS access key ID aws_secret_access_key (Optional[str]): the AWS secret access key aws_session_token (Optional[str]): the AWS session token aws_region_name (Optional[str]): the AWS region name \"\"\" super () . __init__ ( service_name = \"cloudwatch\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . namespace = namespace self . dimensions_list = dimensions_list self . metric_name = metric_name self . metric_id = metric_id self . metric_unit = metric_unit self . ec2_resource = boto3 . resource ( service_name = \"ec2\" , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , ) get_ec2_uptime ( ec2_instance_id , days , hours , minutes ) Get the runtime of an EC2 instance Parameters: Name Type Description Default ec2_instance_id str the ID of the EC2 instance required days int how many days to subtract from the current date to determine the metric collection start time required hours int how many hours to subtract from the current time to determine the metric collection start time required minutes int how many minutes to subtract from the current time to determine the metric collection start time required Returns: Name Type Description int int the runtime of the EC2 instance in minutes Source code in cloudwatcher/metricwatcher.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def get_ec2_uptime ( self , ec2_instance_id : str , days : int , hours : int , minutes : int , ) -> int : \"\"\" Get the runtime of an EC2 instance Args: ec2_instance_id (str): the ID of the EC2 instance days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time Returns: int: the runtime of the EC2 instance in minutes \"\"\" if not self . is_ec2_running ( ec2_instance_id ): _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is not running anymore. \" f \"Uptime will be estimated based on reported metrics in \" f \"the last { days } days\" ) instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) # get the latest reported metric metrics_response = self . query_ec2_metrics ( days = days , hours = hours , minutes = minutes , stat = \"Maximum\" , # any stat works period = 60 , # most precise period that AWS stores for instances where # start time is between 3 hours and 15 days ago ) # extract the latest metric report time timed_metrics = self . timed_metric_factory ( metrics_response ) try : earliest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ 0 ] latest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ - 1 ] return ( earliest_metric_report_time - latest_metric_report_time ) . total_seconds () except IndexError : _LOGGER . warning ( f \"No metric data found for EC2: { self . dimension_value } \" ) return instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) for instance in instances : _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is still running. \" f \"Launch time: { instance . launch_time } \" ) return ( datetime . now ( pytz . utc ) - instance . launch_time ) . total_seconds () is_ec2_running ( ec2_instance_id ) Check if EC2 instance is running Parameters: Name Type Description Default ec2_instance_id str the ID of the EC2 instance required Returns: Name Type Description bool bool True if EC2 instance is running, False otherwise Source code in cloudwatcher/metricwatcher.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def is_ec2_running ( self , ec2_instance_id : str ) -> bool : \"\"\" Check if EC2 instance is running Args: ec2_instance_id (str): the ID of the EC2 instance Returns: bool: True if EC2 instance is running, False otherwise \"\"\" instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ ec2_instance_id ]}] ) if len ( list ( instances )) == 0 : return None if len ( list ( instances )) > 1 : raise Exception ( f \"Multiple EC2 instances matched by ID: { ec2_instance_id } \" ) for instance in instances : # check the status codes and their meanings: # https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501 if instance . state [ \"Code\" ] <= 16 : return True return False log_metric ( response = None , query_preset = None ) Query and log the metric data Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query None Source code in cloudwatcher/metricwatcher.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def log_metric ( self , response : Optional [ Dict ] = None , query_preset : Optional [ str ] = None ): \"\"\" Query and log the metric data Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricLogger , target = None , # TODO: add support for saving to file response = response , ) log_metric_summary ( response = None ) Query and summarize the metric data to a JSON file Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def log_metric_summary ( self , response : Optional [ Dict ] = None ): \"\"\" Query and summarize the metric data to a JSON file Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricSummarizer , target = None , # TODO: add support for saving to file metric_unit = self . metric_unit , summarizer = ( \"Max\" , max ), response = response , ) log_response ( response = None ) Query and log the response Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 410 411 412 413 414 415 416 417 418 419 420 421 422 def log_response ( self , response : Optional [ Dict ] = None ): \"\"\" Query and log the response Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseLogger , target = None , response = response , ) query_ec2_metrics ( days , hours , minutes , stat , period ) Query EC2 metrics Parameters: Name Type Description Default days int how many days to subtract from the current date to determine the metric collection start time required hours int how many hours to subtract from the current time to determine the metric collection start time required minutes int how many minutes to subtract from the current time to determine the metric collection start time required stat str the statistic to query required period int the period of the metric required Returns: Name Type Description Dict Dict the response from the query, check the structure of the Dict response here # noqa: E501 Source code in cloudwatcher/metricwatcher.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def query_ec2_metrics ( self , days : int , hours : int , minutes : int , stat : str , period : int , ) -> Dict : \"\"\" Query EC2 metrics Args: days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time stat (str): the statistic to query period (int): the period of the metric Returns: Dict: the response from the query, check the structure of the response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501 \"\"\" # Create CloudWatch client now = datetime . datetime . now ( pytz . utc ) start_time = now - datetime . timedelta ( days = days , hours = hours , minutes = minutes ) _time = lambda x : x . strftime ( \"%Y-%m- %d %H:%M:%S\" ) _LOGGER . info ( f \"Querying ' { self . metric_name } ' for dimensions { self . dimensions_list } \" f \"from { _time ( start_time ) } to { _time ( now ) } \" ) response = self . client . get_metric_data ( MetricDataQueries = [ { \"Id\" : self . metric_id , \"MetricStat\" : { \"Metric\" : { \"Namespace\" : self . namespace , \"MetricName\" : self . metric_name , \"Dimensions\" : [ dim . dict () for dim in self . dimensions_list ], }, \"Stat\" : stat , \"Unit\" : str ( self . metric_unit ), # str(None) is desired, if no unit is specified \"Period\" : period , }, }, ], StartTime = start_time , EndTime = now , ) resp_status = response [ \"ResponseMetadata\" ][ \"HTTPStatusCode\" ] if resp_status != 200 : _LOGGER . error ( f \"Invalid response status code: { resp_status } \" ) return _LOGGER . debug ( f \"Response status code: { resp_status } \" ) return response save_metric_csv ( file_path , response = None , query_kwargs = None ) Query and save the metric data to a CSV file Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def save_metric_csv ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a CSV file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricCsvSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) save_metric_json ( file_path , response = None , query_kwargs = None ) Query and save the metric data to a JSON file Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def save_metric_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a JSON file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricJsonSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) save_metric_plot ( file_path , response = None , query_kwargs = None ) Query and plot the metric data Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def save_metric_plot ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and plot the metric data Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricPlotter , target = file_path , metric_unit = self . metric_unit , response = response , query_kwargs = query_kwargs , ) save_response_json ( file_path , response = None , query_kwargs = None ) Query and save the response data to a JSON file Parameters: Name Type Description Default file_path str the file path to save the response data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def save_response_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the response data to a JSON file Args: file_path (str): the file path to save the response data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) timed_metric_factory ( response ) staticmethod Create a collection of TimedMetrics from the CloudWatch client response. Parameters: Name Type Description Default response dict the response from the query required Returns: Type Description List [ TimedMetric ] List[TimedMetric]: a collection of TimedMetrics Source code in cloudwatcher/metricwatcher.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 @staticmethod def timed_metric_factory ( response : dict ) -> List [ TimedMetric ]: \"\"\" Create a collection of TimedMetrics from the CloudWatch client response. Args: response (dict): the response from the query Returns: List[TimedMetric]: a collection of TimedMetrics \"\"\" return [ TimedMetric ( label = metric_data_result [ \"Label\" ], timestamps = metric_data_result [ \"Timestamps\" ], values = metric_data_result [ \"Values\" ], ) for metric_data_result in response [ \"MetricDataResults\" ] ] MetricWatcherSetup A class for the setup of the MetricWatcher Source code in cloudwatcher/preset.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @dataclass class MetricWatcherSetup : \"\"\" A class for the setup of the MetricWatcher \"\"\" namespace : str dimensions_list : List [ Dimension ] metric_name : str metric_id : str metric_unit : str aws_access_key_id : str = None aws_secret_access_key : str = None aws_session_token : str = None aws_region_name : str = None def __post_init__ ( self ): self . aws_access_key_id = self . aws_access_key_id or os . environ . get ( \"AWS_ACCESS_KEY_ID\" ) self . aws_secret_access_key = self . aws_secret_access_key or os . environ . get ( \"AWS_SECRET_ACCESS_KEY\" ) self . aws_session_token = self . aws_session_token or os . environ . get ( \"AWS_SESSION_TOKEN\" ) self . aws_region_name = self . aws_region_name or os . environ . get ( \"AWS_DEFAULT_REGION\" ) self . dimensions_list = [ Dimension ( ** dimension ) for dimension in self . dimensions_list ] @classmethod def from_dict ( cls , data : dict ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a dictionary Args: data (dict): The dictionary to use \"\"\" return cls ( ** data ) @classmethod def from_json ( cls , file_path : str ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a JSON file Args: file_path (str): The path to the JSON file \"\"\" with open ( file_path ) as f : data = json . load ( f ) return cls . from_dict ( data ) def to_dict ( self ) -> dict : \"\"\" Convert the MetricWatcherSetup object to a dictionary Returns: dict: The dictionary representation of the object \"\"\" return self . __dict__ def upsert_dimensions ( self , dimensions_specs : List [ str ] = None ): \"\"\" Upsert the dimensions list with the dimensions specified in the environment Args: dimensions_spec (List[str]): A list of strings in the format of \"Name:Value\" \"\"\" if dimensions_specs is None : return for dimension_spec in dimensions_specs : name , value = dimension_spec . split ( \":\" ) for dimension in self . dimensions_list : if dimension . Name == name : dimension . Value = value break else : self . dimensions_list . append ( Dimension ( Name = name , Value = value )) from_dict ( data ) classmethod Create a MetricWatcherSetup object from a dictionary Parameters: Name Type Description Default data dict The dictionary to use required Source code in cloudwatcher/preset.py 161 162 163 164 165 166 167 168 169 @classmethod def from_dict ( cls , data : dict ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a dictionary Args: data (dict): The dictionary to use \"\"\" return cls ( ** data ) from_json ( file_path ) classmethod Create a MetricWatcherSetup object from a JSON file Parameters: Name Type Description Default file_path str The path to the JSON file required Source code in cloudwatcher/preset.py 171 172 173 174 175 176 177 178 179 180 181 @classmethod def from_json ( cls , file_path : str ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a JSON file Args: file_path (str): The path to the JSON file \"\"\" with open ( file_path ) as f : data = json . load ( f ) return cls . from_dict ( data ) to_dict () Convert the MetricWatcherSetup object to a dictionary Returns: Name Type Description dict dict The dictionary representation of the object Source code in cloudwatcher/preset.py 183 184 185 186 187 188 189 190 def to_dict ( self ) -> dict : \"\"\" Convert the MetricWatcherSetup object to a dictionary Returns: dict: The dictionary representation of the object \"\"\" return self . __dict__ upsert_dimensions ( dimensions_specs = None ) Upsert the dimensions list with the dimensions specified in the environment Parameters: Name Type Description Default dimensions_spec List [ str ] A list of strings in the format of \"Name:Value\" required Source code in cloudwatcher/preset.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def upsert_dimensions ( self , dimensions_specs : List [ str ] = None ): \"\"\" Upsert the dimensions list with the dimensions specified in the environment Args: dimensions_spec (List[str]): A list of strings in the format of \"Name:Value\" \"\"\" if dimensions_specs is None : return for dimension_spec in dimensions_specs : name , value = dimension_spec . split ( \":\" ) for dimension in self . dimensions_list : if dimension . Name == name : dimension . Value = value break else : self . dimensions_list . append ( Dimension ( Name = name , Value = value )) PresetFilesInventory Source code in cloudwatcher/preset.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PresetFilesInventory : def __init__ ( self , presets_dir : Union [ Path , str ] = None ) -> None : \"\"\" Initialize the preset inventory Args: presets_dir (Path): The path to the presets directory Raises: ValueError: If the presets directory does not exist \"\"\" preset_dir = ( Path ( presets_dir ) if presets_dir is not None else Path ( __file__ ) . parent / \"presets\" ) if not preset_dir . exists (): raise ValueError ( f \"Presets directory { preset_dir } does not exist\" ) self . _presets_dir = preset_dir _LOGGER . debug ( f \"Presets directory: { self . presets_dir } \" ) self . _presets = self . _get_available_presets ( self . presets_dir ) def _get_available_presets ( self , presets_dir : Path ) -> List [ str ]: return { preset_file . stem : preset_file for preset_file in presets_dir . iterdir () if preset_file . is_file () and preset_file . suffix == \".json\" } @property def presets_table ( self ) -> Table : \"\"\" Get a rich table with the available presets Returns: Table: The rich table \"\"\" table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( \"Name\" ) table . add_column ( \"Path\" , style = \"dim\" ) for preset_name , preset_path in self . presets . items (): table . add_row ( preset_name , preset_path . as_posix ()) table . title = f \"Presets available in: { self . presets_dir } \" return table @property def presets ( self ) -> Dict [ str , Path ]: \"\"\" Get the available presets Returns: Dict[str, Path]: The available presets \"\"\" return self . _presets @property def presets_list ( self ) -> List [ str ]: \"\"\" Get the list of available presets Returns: List[str]: The list of available presets \"\"\" return list ( self . _presets . keys ()) @property def presets_dir ( self ) -> Path : \"\"\" Get the presets directory Returns: Path: The presets directory \"\"\" return self . _presets_dir def get_preset_path ( self , preset_name : str ) -> Path : \"\"\" Get the preset file content Args: preset_name (str): The name of the preset Returns: Path: the path to the preset file \"\"\" if preset_name not in self . presets : raise ValueError ( f \"Preset { preset_name } not found. Available presets: \" f \" { ', ' . join ( self . presets . keys ()) } \" ) return self . presets [ preset_name ] __init__ ( presets_dir = None ) Initialize the preset inventory Parameters: Name Type Description Default presets_dir Path The path to the presets directory None Raises: Type Description ValueError If the presets directory does not exist Source code in cloudwatcher/preset.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , presets_dir : Union [ Path , str ] = None ) -> None : \"\"\" Initialize the preset inventory Args: presets_dir (Path): The path to the presets directory Raises: ValueError: If the presets directory does not exist \"\"\" preset_dir = ( Path ( presets_dir ) if presets_dir is not None else Path ( __file__ ) . parent / \"presets\" ) if not preset_dir . exists (): raise ValueError ( f \"Presets directory { preset_dir } does not exist\" ) self . _presets_dir = preset_dir _LOGGER . debug ( f \"Presets directory: { self . presets_dir } \" ) self . _presets = self . _get_available_presets ( self . presets_dir ) get_preset_path ( preset_name ) Get the preset file content Parameters: Name Type Description Default preset_name str The name of the preset required Returns: Name Type Description Path Path the path to the preset file Source code in cloudwatcher/preset.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def get_preset_path ( self , preset_name : str ) -> Path : \"\"\" Get the preset file content Args: preset_name (str): The name of the preset Returns: Path: the path to the preset file \"\"\" if preset_name not in self . presets : raise ValueError ( f \"Preset { preset_name } not found. Available presets: \" f \" { ', ' . join ( self . presets . keys ()) } \" ) return self . presets [ preset_name ] presets () property Get the available presets Returns: Type Description Dict [ str , Path ] Dict[str, Path]: The available presets Source code in cloudwatcher/preset.py 61 62 63 64 65 66 67 68 69 @property def presets ( self ) -> Dict [ str , Path ]: \"\"\" Get the available presets Returns: Dict[str, Path]: The available presets \"\"\" return self . _presets presets_dir () property Get the presets directory Returns: Name Type Description Path Path The presets directory Source code in cloudwatcher/preset.py 81 82 83 84 85 86 87 88 89 @property def presets_dir ( self ) -> Path : \"\"\" Get the presets directory Returns: Path: The presets directory \"\"\" return self . _presets_dir presets_list () property Get the list of available presets Returns: Type Description List [ str ] List[str]: The list of available presets Source code in cloudwatcher/preset.py 71 72 73 74 75 76 77 78 79 @property def presets_list ( self ) -> List [ str ]: \"\"\" Get the list of available presets Returns: List[str]: The list of available presets \"\"\" return list ( self . _presets . keys ()) presets_table () property Get a rich table with the available presets Returns: Name Type Description Table Table The rich table Source code in cloudwatcher/preset.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @property def presets_table ( self ) -> Table : \"\"\" Get a rich table with the available presets Returns: Table: The rich table \"\"\" table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( \"Name\" ) table . add_column ( \"Path\" , style = \"dim\" ) for preset_name , preset_path in self . presets . items (): table . add_row ( preset_name , preset_path . as_posix ()) table . title = f \"Presets available in: { self . presets_dir } \" return table Metric handlers Handler Bases: ABC Abstract class to establish the interface for data handling Source code in cloudwatcher/metric_handlers.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Handler ( ABC ): \"\"\" Abstract class to establish the interface for data handling \"\"\" @abstractmethod def __init__ ( self , response : dict , logger : logging . Logger ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API logger (logging.Logger): The logger to use \"\"\" pass @abstractmethod def __call__ ( self , target : str ) -> None : \"\"\" Execute the handler Args: target (str): The target to use for the handler \"\"\" pass __call__ ( target ) abstractmethod Execute the handler Parameters: Name Type Description Default target str The target to use for the handler required Source code in cloudwatcher/metric_handlers.py 80 81 82 83 84 85 86 87 88 @abstractmethod def __call__ ( self , target : str ) -> None : \"\"\" Execute the handler Args: target (str): The target to use for the handler \"\"\" pass __init__ ( response , logger ) abstractmethod Initialize the handler Parameters: Name Type Description Default response dict The response from the AWS API required logger logging . Logger The logger to use required Source code in cloudwatcher/metric_handlers.py 69 70 71 72 73 74 75 76 77 78 @abstractmethod def __init__ ( self , response : dict , logger : logging . Logger ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API logger (logging.Logger): The logger to use \"\"\" pass ResponseHandler Bases: Handler Abstract class to establish the interface for a response handling Source code in cloudwatcher/metric_handlers.py 91 92 93 94 95 96 97 98 99 100 101 102 103 class ResponseHandler ( Handler ): \"\"\" Abstract class to establish the interface for a response handling \"\"\" def __init__ ( self , response : dict ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API \"\"\" self . response = response __init__ ( response ) Initialize the handler Parameters: Name Type Description Default response dict The response from the AWS API required Source code in cloudwatcher/metric_handlers.py 96 97 98 99 100 101 102 103 def __init__ ( self , response : dict ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API \"\"\" self . response = response ResponseLogger Bases: ResponseHandler Log the response to the console Source code in cloudwatcher/metric_handlers.py 138 139 140 141 142 143 144 145 146 147 148 class ResponseLogger ( ResponseHandler ): \"\"\" Log the response to the console \"\"\" def __call__ ( self , target : str ) -> None : if target is not None : raise NotImplementedError ( \"Logging responses to a file is not yet implemented.\" ) _LOGGER . debug ( json . dumps ( self . response , indent = 4 , default = str )) ResponseSaver Bases: ResponseHandler Save the response to a file Source code in cloudwatcher/metric_handlers.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class ResponseSaver ( ResponseHandler ): \"\"\" Save the response to a file \"\"\" def __call__ ( self , target : str ) -> None : \"\"\" Save the response to a file Args: target (str): The target file to save the response to \"\"\" with open ( target , \"w\" ) as f : json . dump ( self . response , f , indent = 4 , default = str ) _LOGGER . info ( f \"Saved response to: { target } \" ) __call__ ( target ) Save the response to a file Parameters: Name Type Description Default target str The target file to save the response to required Source code in cloudwatcher/metric_handlers.py 126 127 128 129 130 131 132 133 134 135 def __call__ ( self , target : str ) -> None : \"\"\" Save the response to a file Args: target (str): The target file to save the response to \"\"\" with open ( target , \"w\" ) as f : json . dump ( self . response , f , indent = 4 , default = str ) _LOGGER . info ( f \"Saved response to: { target } \" ) TimedMetric dataclass Timed metric object Parameters: Name Type Description Default timestamps List [ datetime ] The timestamps of the metric required values List [ float ] The values of the metric required label str The label of the metric required Source code in cloudwatcher/metric_handlers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass class TimedMetric : \"\"\" Timed metric object Args: timestamps (List[datetime]): The timestamps of the metric values (List[float]): The values of the metric label (str): The label of the metric \"\"\" label : str timestamps : List [ datetime ] values : List [ str ] def __len__ ( self ): if len ( self . timestamps ) == len ( self . values ): return len ( self . values ) raise ValueError ( \"The internal timed metric lengths are not equal\" ) TimedMetricCsvSaver Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class TimedMetricCsvSaver ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a csv file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" , encoding = \"UTF8\" , newline = \"\" ) as f : writer = csv . writer ( f ) # write the header writer . writerow ([ \"time\" , \"value\" ]) # write the data for i in range ( len ( self . timed_metric )): writer . writerow ( [ self . timed_metric . timestamps [ i ], self . timed_metric . values [ i ]] ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" ) __call__ ( target ) Write the object to a csv file Parameters: Name Type Description Default target str The target file to save the object to required Source code in cloudwatcher/metric_handlers.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a csv file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" , encoding = \"UTF8\" , newline = \"\" ) as f : writer = csv . writer ( f ) # write the header writer . writerow ([ \"time\" , \"value\" ]) # write the data for i in range ( len ( self . timed_metric )): writer . writerow ( [ self . timed_metric . timestamps [ i ], self . timed_metric . values [ i ]] ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" ) TimedMetricHandler Bases: Handler Class to establish the interface for a timed metric handling Source code in cloudwatcher/metric_handlers.py 106 107 108 109 110 111 112 113 114 115 116 117 118 class TimedMetricHandler ( Handler ): \"\"\" Class to establish the interface for a timed metric handling \"\"\" def __init__ ( self , timed_metric : TimedMetric ) -> None : \"\"\" Initialize the handler Args: timed_metric (TimedMetric): The timed metric to use \"\"\" self . timed_metric = timed_metric __init__ ( timed_metric ) Initialize the handler Parameters: Name Type Description Default timed_metric TimedMetric The timed metric to use required Source code in cloudwatcher/metric_handlers.py 111 112 113 114 115 116 117 118 def __init__ ( self , timed_metric : TimedMetric ) -> None : \"\"\" Initialize the handler Args: timed_metric (TimedMetric): The timed metric to use \"\"\" self . timed_metric = timed_metric TimedMetricJsonSaver Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class TimedMetricJsonSaver ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a json file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" ) as f : json . dump ( { \"Label\" : self . timed_metric . label , \"Timestamps\" : self . timed_metric . timestamps , \"Values\" : self . timed_metric . values , }, f , indent = 4 , default = str , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" ) __call__ ( target ) Write the object to a json file Parameters: Name Type Description Default target str The target file to save the object to required Source code in cloudwatcher/metric_handlers.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a json file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" ) as f : json . dump ( { \"Label\" : self . timed_metric . label , \"Timestamps\" : self . timed_metric . timestamps , \"Values\" : self . timed_metric . values , }, f , indent = 4 , default = str , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" ) TimedMetricLogger Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 class TimedMetricLogger ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Log the timed metric as a table \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( f \"Time ( { str ( pytz . utc ) } )\" , style = \"dim\" , justify = \"center\" ) table . add_column ( \"Value\" ) values = [ self . mem_to_str ( v ) if self . timed_metric . label . startswith ( \"mem\" ) else str ( v ) for v in self . timed_metric . values ] for i in range ( len ( self . timed_metric . timestamps )): table . add_row ( self . timed_metric . timestamps [ i ] . strftime ( \"%H:%M:%S\" ), values [ i ] ) console = Console () console . print ( table ) @staticmethod def mem_to_str ( size : int , precision : int = 3 ) -> str : \"\"\" Convert bytes to human readable string Args: size (int): The size in bytes precision (int): The precision to use, number of decimal places Returns: str: The human readable string \"\"\" size , suffix = convert_mem ( size ) return \" %.*f %s \" % ( precision , size , suffix ) __call__ ( target ) Log the timed metric as a table Source code in cloudwatcher/metric_handlers.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def __call__ ( self , target : str ) -> None : \"\"\" Log the timed metric as a table \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( f \"Time ( { str ( pytz . utc ) } )\" , style = \"dim\" , justify = \"center\" ) table . add_column ( \"Value\" ) values = [ self . mem_to_str ( v ) if self . timed_metric . label . startswith ( \"mem\" ) else str ( v ) for v in self . timed_metric . values ] for i in range ( len ( self . timed_metric . timestamps )): table . add_row ( self . timed_metric . timestamps [ i ] . strftime ( \"%H:%M:%S\" ), values [ i ] ) console = Console () console . print ( table ) mem_to_str ( size , precision = 3 ) staticmethod Convert bytes to human readable string Parameters: Name Type Description Default size int The size in bytes required precision int The precision to use, number of decimal places 3 Returns: Name Type Description str str The human readable string Source code in cloudwatcher/metric_handlers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @staticmethod def mem_to_str ( size : int , precision : int = 3 ) -> str : \"\"\" Convert bytes to human readable string Args: size (int): The size in bytes precision (int): The precision to use, number of decimal places Returns: str: The human readable string \"\"\" size , suffix = convert_mem ( size ) return \" %.*f %s \" % ( precision , size , suffix ) TimedMetricPlotter Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class TimedMetricPlotter ( TimedMetricHandler ): def __call__ ( self , target : str , metric_unit : str ) -> None : \"\"\" Plot the timed metric Args: target (str): The target file to save the plot to metric_unit (str): The unit of the metric \"\"\" values = self . timed_metric . values if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : metric_unit = \"GB\" values = [ convert_mem ( v , force_suffix = metric_unit )[ 0 ] for v in values ] plt . plot ( self . timed_metric . timestamps , values , linewidth = 0.8 , ) plt . title ( f \" { self . timed_metric . label } over time\" , loc = \"right\" , fontstyle = \"italic\" , ) plt . ylabel ( f \" { self . timed_metric . label } ( { metric_unit } )\" ) plt . ticklabel_format ( axis = \"y\" , style = \"plain\" , useOffset = False ) plt . tick_params ( left = True , bottom = False , labelleft = True , labelbottom = False ) plt . savefig ( target , bbox_inches = \"tight\" , pad_inches = 0.1 , dpi = 300 , format = \"png\" , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' plot to: { target } \" ) __call__ ( target , metric_unit ) Plot the timed metric Parameters: Name Type Description Default target str The target file to save the plot to required metric_unit str The unit of the metric required Source code in cloudwatcher/metric_handlers.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def __call__ ( self , target : str , metric_unit : str ) -> None : \"\"\" Plot the timed metric Args: target (str): The target file to save the plot to metric_unit (str): The unit of the metric \"\"\" values = self . timed_metric . values if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : metric_unit = \"GB\" values = [ convert_mem ( v , force_suffix = metric_unit )[ 0 ] for v in values ] plt . plot ( self . timed_metric . timestamps , values , linewidth = 0.8 , ) plt . title ( f \" { self . timed_metric . label } over time\" , loc = \"right\" , fontstyle = \"italic\" , ) plt . ylabel ( f \" { self . timed_metric . label } ( { metric_unit } )\" ) plt . ticklabel_format ( axis = \"y\" , style = \"plain\" , useOffset = False ) plt . tick_params ( left = True , bottom = False , labelleft = True , labelbottom = False ) plt . savefig ( target , bbox_inches = \"tight\" , pad_inches = 0.1 , dpi = 300 , format = \"png\" , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' plot to: { target } \" ) TimedMetricSummarizer Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class TimedMetricSummarizer ( TimedMetricHandler ): def __call__ ( self , target : str , metric_unit : str , summarizer : Tuple [ str , callable ], ) -> None : \"\"\" Summarize the metric Args: target (str): The target file to save the summary to metric_unit (str): The unit of the metric summarizer (Tuple[str, callable]): The summarizer to use and the function to use \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) timespan = self . timed_metric . timestamps [ 0 ] - self . timed_metric . timestamps [ - 1 ] _LOGGER . info ( f \"Retrieved ' { self . timed_metric . label } ' { len ( self . timed_metric . values ) } \" f \"measurements over { timespan } timespan\" ) summary = summarizer [ 1 ]( self . timed_metric . values ) if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : mem , metric_unit = convert_mem ( summary ) _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { mem : .2f } { metric_unit } over { timespan } timespan\" ) else : _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { summary } over { timespan } timespan\" ) __call__ ( target , metric_unit , summarizer ) Summarize the metric Parameters: Name Type Description Default target str The target file to save the summary to required metric_unit str The unit of the metric required summarizer Tuple [ str , callable ] The summarizer to use and the function to use required Source code in cloudwatcher/metric_handlers.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def __call__ ( self , target : str , metric_unit : str , summarizer : Tuple [ str , callable ], ) -> None : \"\"\" Summarize the metric Args: target (str): The target file to save the summary to metric_unit (str): The unit of the metric summarizer (Tuple[str, callable]): The summarizer to use and the function to use \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) timespan = self . timed_metric . timestamps [ 0 ] - self . timed_metric . timestamps [ - 1 ] _LOGGER . info ( f \"Retrieved ' { self . timed_metric . label } ' { len ( self . timed_metric . values ) } \" f \"measurements over { timespan } timespan\" ) summary = summarizer [ 1 ]( self . timed_metric . values ) if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : mem , metric_unit = convert_mem ( summary ) _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { mem : .2f } { metric_unit } over { timespan } timespan\" ) else : _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { summary } over { timespan } timespan\" ) convert_mem ( value , force_suffix = None ) Convert memory in bytes to the highest possible, or desired memory unit Parameters: Name Type Description Default value int The memory in bytes required force_suffix str The desired memory unit None Returns: Type Description Tuple [ float , str ] Tuple[float, str]: The memory in the desired unit and the unit Source code in cloudwatcher/metric_handlers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def convert_mem ( value : int , force_suffix : str = None ) -> Tuple [ float , str ]: \"\"\" Convert memory in bytes to the highest possible, or desired memory unit Args: value (int): The memory in bytes force_suffix (str): The desired memory unit Returns: Tuple[float, str]: The memory in the desired unit and the unit \"\"\" suffixes = [ \"B\" , \"KB\" , \"MB\" , \"GB\" , \"TB\" ] if force_suffix is not None : try : idx = suffixes . index ( force_suffix ) except ValueError : raise ValueError ( f \"Forced memory unit must me one of: { suffixes } \" ) else : return value / float ( pow ( 1024 , idx )), force_suffix suffixIndex = 0 while value > 1024 and suffixIndex < len ( suffixes ) - 1 : suffixIndex += 1 value = value / 1024.0 return value , suffixes [ suffixIndex ]","title":"API documentation"},{"location":"API_documentation/#api-documentation","text":"","title":"API documentation"},{"location":"API_documentation/#cloudwatcher","text":"A base class for CloudWatch managers Source code in cloudwatcher/cloudwatcher.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class CloudWatcher : \"\"\" A base class for CloudWatch managers \"\"\" def __init__ ( self , service_name : str , aws_region_name : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , ) -> None : \"\"\" Initialize CloudWatcher Args: service_name (str): The name of the service to use aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None \"\"\" self . aws_region_name = aws_region_name or \"us-east-1\" self . service_name = service_name self . client : boto3 . Session . client = boto3 . client ( service_name = self . service_name , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , )","title":"CloudWatcher"},{"location":"API_documentation/#cloudwatcher.cloudwatcher.CloudWatcher.__init__","text":"Initialize CloudWatcher Parameters: Name Type Description Default service_name str The name of the service to use required aws_region_name Optional [ str ] The AWS region name. Defaults to 'us-east-1' None aws_access_key_id Optional [ str ] The AWS access key ID. Defaults to None None aws_secret_access_key Optional [ str ] The AWS secret access key. Defaults to None None aws_session_token Optional [ str ] The AWS session token. Defaults to None None Source code in cloudwatcher/cloudwatcher.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def __init__ ( self , service_name : str , aws_region_name : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , ) -> None : \"\"\" Initialize CloudWatcher Args: service_name (str): The name of the service to use aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None \"\"\" self . aws_region_name = aws_region_name or \"us-east-1\" self . service_name = service_name self . client : boto3 . Session . client = boto3 . client ( service_name = self . service_name , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , )","title":"__init__()"},{"location":"API_documentation/#logwatcher","text":"Bases: CloudWatcher A class for AWS CloudWatch log events retrieval and parsing Source code in cloudwatcher/logwatcher.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 class LogWatcher ( CloudWatcher ): \"\"\" A class for AWS CloudWatch log events retrieval and parsing \"\"\" def __init__ ( self , log_group_name : str , log_stream_name : str , start_token : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize LogWatcher Args: log_group_name (str): The name of the log group log_stream_name (str): The name of the log stream start_token (Optional[str]): The token to use for the next query. Defaults to None aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' \"\"\" super () . __init__ ( service_name = \"logs\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . log_group_name = log_group_name self . log_stream_name = log_stream_name self . start_token = start_token def __repr__ ( self ) -> str : \"\"\" Return a string representation of the object Returns: str: The string representation of the object \"\"\" return f \"LogWatcher(' { self . log_group_name } / { self . log_stream_name } ')\" def check_log_exists ( self ) -> bool : \"\"\" Check if the log stream exists Returns: bool: True if the log stream exists, False otherwise \"\"\" try : response = self . client . describe_log_streams ( logGroupName = self . log_group_name , logStreamNamePrefix = self . log_stream_name , ) return True if response [ \"logStreams\" ] else False except Exception as e : _LOGGER . error ( f \"Error checking if log stream exists: { e } \" ) return False def _get_events ( self , query_kwargs : Dict [ str , Any ]) -> List [ Event ]: \"\"\" Get events from CloudWatch and update the arguments for the next query with 'nextForwardToken' Args: query_kwargs (Dict[str, Any]): The query arguments Returns: List[Event]: The list of log events \"\"\" response = self . client . get_log_events ( ** query_kwargs ) query_kwargs . update ({ \"nextToken\" : response [ \"nextForwardToken\" ]}) return response [ \"events\" ], response [ \"nextForwardToken\" ] def stream_cloudwatch_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> List [ Event ]: \"\"\" A generator that retrieves desired number of log events per iteration Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: List[Event]: The list of log events \"\"\" query_kwargs = dict ( logGroupName = self . log_group_name , logStreamName = self . log_stream_name , limit = events_limit , startFromHead = True , ) if self . start_token : query_kwargs . update ({ \"nextToken\" : self . start_token }) _LOGGER . debug ( f \"Retrieving log events from: { self . log_group_name } / { self . log_stream_name } \" ) events , token = self . _get_events ( query_kwargs ) yield events , token while events : events , token = self . _get_events ( query_kwargs ) retry_attempts = 0 while not events and max_retry_attempts > retry_attempts : events , token = self . _get_events ( query_kwargs ) retry_attempts += 1 _LOGGER . debug ( f \"Received empty log events list. Retry attempt: { retry_attempts } \" ) yield events , token def stream_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 , sep : str = \"<br>\" , ) -> Tuple [ List [ str ], str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. sep (str): The separator to use between log events. Returns: Tuple[List[str], str]: The list of formatted log events and the next token \"\"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts , ): yield sep . join ( self . format_logs_events ( log_events = events )), token def return_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> Tuple [ str , str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: Tuple[str, str]: The list of formatted log events and the next token \"\"\" formatted_events = \"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts ): formatted_events += \" \\n \" . join ( self . format_logs_events ( log_events = events )) return formatted_events , token def format_logs_events ( self , log_events : List [ Event ], regex : str = r \"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\" , fmt_str : str = \"[ {time} UTC] {message} \" , ) -> List [ str ]: \"\"\" Format log events Args: log_events (List[Event]): The list of log events. regex (str): The regex to use to extract the time and message. fmt_str (str): The format string to use to format the time and message. \"\"\" def _datestr ( timestamp : int , fmt_str : str = \" %d -%m-%Y %H:%M:%S\" ) -> str : \"\"\" Convert milliseconds after Jan 1, 1970 UTC to a string date repr Args: timestamp (int): milliseconds after Jan 1, 1970 UTC fmt_str (str): format string for the date Returns: str: date string \"\"\" return datetime . fromtimestamp ( timestamp / 1000.0 ) . strftime ( fmt_str ) formatted_log_list = [] for e in log_events : m = re . search ( regex , e [ \"message\" ]) msg = e [ \"message\" ][ m . end () :] if m else e [ \"message\" ] formatted_log_list . append ( fmt_str . format ( time = _datestr ( e [ \"timestamp\" ]), message = msg . strip ()) ) return formatted_log_list def save_log_file ( self , file_path : str ) -> None : \"\"\" Save the log file to the specified path Args: file_path (str): The path to save the log file to. \"\"\" logs , _ = self . return_formatted_logs () with open ( file_path , \"w\" ) as f : f . write ( logs ) _LOGGER . info ( f \"Logs ' { self . log_group_name } / { self . log_stream_name } ' saved to: { file_path } \" )","title":"LogWatcher"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.__init__","text":"Initialize LogWatcher Parameters: Name Type Description Default log_group_name str The name of the log group required log_stream_name str The name of the log stream required start_token Optional [ str ] The token to use for the next query. Defaults to None None aws_access_key_id Optional [ str ] The AWS access key ID. Defaults to None None aws_secret_access_key Optional [ str ] The AWS secret access key. Defaults to None None aws_session_token Optional [ str ] The AWS session token. Defaults to None None aws_region_name Optional [ str ] The AWS region name. Defaults to 'us-east-1' None Source code in cloudwatcher/logwatcher.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def __init__ ( self , log_group_name : str , log_stream_name : str , start_token : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize LogWatcher Args: log_group_name (str): The name of the log group log_stream_name (str): The name of the log stream start_token (Optional[str]): The token to use for the next query. Defaults to None aws_access_key_id (Optional[str]): The AWS access key ID. Defaults to None aws_secret_access_key (Optional[str]): The AWS secret access key. Defaults to None aws_session_token (Optional[str]): The AWS session token. Defaults to None aws_region_name (Optional[str]): The AWS region name. Defaults to 'us-east-1' \"\"\" super () . __init__ ( service_name = \"logs\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . log_group_name = log_group_name self . log_stream_name = log_stream_name self . start_token = start_token","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.__repr__","text":"Return a string representation of the object Returns: Name Type Description str str The string representation of the object Source code in cloudwatcher/logwatcher.py 53 54 55 56 57 58 59 60 def __repr__ ( self ) -> str : \"\"\" Return a string representation of the object Returns: str: The string representation of the object \"\"\" return f \"LogWatcher(' { self . log_group_name } / { self . log_stream_name } ')\"","title":"__repr__()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.check_log_exists","text":"Check if the log stream exists Returns: Name Type Description bool bool True if the log stream exists, False otherwise Source code in cloudwatcher/logwatcher.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 def check_log_exists ( self ) -> bool : \"\"\" Check if the log stream exists Returns: bool: True if the log stream exists, False otherwise \"\"\" try : response = self . client . describe_log_streams ( logGroupName = self . log_group_name , logStreamNamePrefix = self . log_stream_name , ) return True if response [ \"logStreams\" ] else False except Exception as e : _LOGGER . error ( f \"Error checking if log stream exists: { e } \" ) return False","title":"check_log_exists()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.format_logs_events","text":"Format log events Parameters: Name Type Description Default log_events List [ Event ] The list of log events. required regex str The regex to use to extract the time and message. '^\\\\[\\\\d+-\\\\d+-\\\\d+\\\\s\\\\d+:\\\\d+:\\\\d+(.|,)\\\\d+(\\\\]|\\\\s-\\\\s\\\\w+\\\\])' fmt_str str The format string to use to format the time and message. '[{time} UTC] {message}' Source code in cloudwatcher/logwatcher.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def format_logs_events ( self , log_events : List [ Event ], regex : str = r \"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\" , fmt_str : str = \"[ {time} UTC] {message} \" , ) -> List [ str ]: \"\"\" Format log events Args: log_events (List[Event]): The list of log events. regex (str): The regex to use to extract the time and message. fmt_str (str): The format string to use to format the time and message. \"\"\" def _datestr ( timestamp : int , fmt_str : str = \" %d -%m-%Y %H:%M:%S\" ) -> str : \"\"\" Convert milliseconds after Jan 1, 1970 UTC to a string date repr Args: timestamp (int): milliseconds after Jan 1, 1970 UTC fmt_str (str): format string for the date Returns: str: date string \"\"\" return datetime . fromtimestamp ( timestamp / 1000.0 ) . strftime ( fmt_str ) formatted_log_list = [] for e in log_events : m = re . search ( regex , e [ \"message\" ]) msg = e [ \"message\" ][ m . end () :] if m else e [ \"message\" ] formatted_log_list . append ( fmt_str . format ( time = _datestr ( e [ \"timestamp\" ]), message = msg . strip ()) ) return formatted_log_list","title":"format_logs_events()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.return_formatted_logs","text":"A generator that yields formatted log events Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 Returns: Type Description Tuple [ str , str ] Tuple[str, str]: The list of formatted log events and the next token Source code in cloudwatcher/logwatcher.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 def return_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> Tuple [ str , str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: Tuple[str, str]: The list of formatted log events and the next token \"\"\" formatted_events = \"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts ): formatted_events += \" \\n \" . join ( self . format_logs_events ( log_events = events )) return formatted_events , token","title":"return_formatted_logs()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.save_log_file","text":"Save the log file to the specified path Parameters: Name Type Description Default file_path str The path to save the log file to. required Source code in cloudwatcher/logwatcher.py 206 207 208 209 210 211 212 213 214 215 216 217 218 def save_log_file ( self , file_path : str ) -> None : \"\"\" Save the log file to the specified path Args: file_path (str): The path to save the log file to. \"\"\" logs , _ = self . return_formatted_logs () with open ( file_path , \"w\" ) as f : f . write ( logs ) _LOGGER . info ( f \"Logs ' { self . log_group_name } / { self . log_stream_name } ' saved to: { file_path } \" )","title":"save_log_file()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.stream_cloudwatch_logs","text":"A generator that retrieves desired number of log events per iteration Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 Returns: Type Description List [ Event ] List[Event]: The list of log events Source code in cloudwatcher/logwatcher.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def stream_cloudwatch_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 ) -> List [ Event ]: \"\"\" A generator that retrieves desired number of log events per iteration Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. Returns: List[Event]: The list of log events \"\"\" query_kwargs = dict ( logGroupName = self . log_group_name , logStreamName = self . log_stream_name , limit = events_limit , startFromHead = True , ) if self . start_token : query_kwargs . update ({ \"nextToken\" : self . start_token }) _LOGGER . debug ( f \"Retrieving log events from: { self . log_group_name } / { self . log_stream_name } \" ) events , token = self . _get_events ( query_kwargs ) yield events , token while events : events , token = self . _get_events ( query_kwargs ) retry_attempts = 0 while not events and max_retry_attempts > retry_attempts : events , token = self . _get_events ( query_kwargs ) retry_attempts += 1 _LOGGER . debug ( f \"Received empty log events list. Retry attempt: { retry_attempts } \" ) yield events , token","title":"stream_cloudwatch_logs()"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.stream_formatted_logs","text":"A generator that yields formatted log events Parameters: Name Type Description Default events_limit int The number of events to retrieve per iteration. 1000 max_retry_attempts int The number of retry attempts. 5 sep str The separator to use between log events. '<br>' Returns: Type Description Tuple [ List [ str ], str ] Tuple[List[str], str]: The list of formatted log events and the next token Source code in cloudwatcher/logwatcher.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def stream_formatted_logs ( self , events_limit : int = 1000 , max_retry_attempts : int = 5 , sep : str = \"<br>\" , ) -> Tuple [ List [ str ], str ]: \"\"\" A generator that yields formatted log events Args: events_limit (int): The number of events to retrieve per iteration. max_retry_attempts (int): The number of retry attempts. sep (str): The separator to use between log events. Returns: Tuple[List[str], str]: The list of formatted log events and the next token \"\"\" for events , token in self . stream_cloudwatch_logs ( events_limit = events_limit , max_retry_attempts = max_retry_attempts , ): yield sep . join ( self . format_logs_events ( log_events = events )), token","title":"stream_formatted_logs()"},{"location":"API_documentation/#metricwatcher","text":"Bases: CloudWatcher A class for AWS CloudWatch metric retrieval and parsing Source code in cloudwatcher/metricwatcher.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 class MetricWatcher ( CloudWatcher ): \"\"\" A class for AWS CloudWatch metric retrieval and parsing \"\"\" def __init__ ( self , namespace : str , dimensions_list : List [ Dict [ str , str ]], metric_name : str , metric_id : str , metric_unit : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize MetricWatcher Args: namespace (str): the namespace of the metric dimensions_list (List[Dict[str, str]]): the dimensions of the metric metric_name (str): the name of the metric metric_id (str): the ID of the metric metric_unit (Optional[str]): the unit of the metric aws_access_key_id (Optional[str]): the AWS access key ID aws_secret_access_key (Optional[str]): the AWS secret access key aws_session_token (Optional[str]): the AWS session token aws_region_name (Optional[str]): the AWS region name \"\"\" super () . __init__ ( service_name = \"cloudwatch\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . namespace = namespace self . dimensions_list = dimensions_list self . metric_name = metric_name self . metric_id = metric_id self . metric_unit = metric_unit self . ec2_resource = boto3 . resource ( service_name = \"ec2\" , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , ) def query_ec2_metrics ( self , days : int , hours : int , minutes : int , stat : str , period : int , ) -> Dict : \"\"\" Query EC2 metrics Args: days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time stat (str): the statistic to query period (int): the period of the metric Returns: Dict: the response from the query, check the structure of the response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501 \"\"\" # Create CloudWatch client now = datetime . datetime . now ( pytz . utc ) start_time = now - datetime . timedelta ( days = days , hours = hours , minutes = minutes ) _time = lambda x : x . strftime ( \"%Y-%m- %d %H:%M:%S\" ) _LOGGER . info ( f \"Querying ' { self . metric_name } ' for dimensions { self . dimensions_list } \" f \"from { _time ( start_time ) } to { _time ( now ) } \" ) response = self . client . get_metric_data ( MetricDataQueries = [ { \"Id\" : self . metric_id , \"MetricStat\" : { \"Metric\" : { \"Namespace\" : self . namespace , \"MetricName\" : self . metric_name , \"Dimensions\" : [ dim . dict () for dim in self . dimensions_list ], }, \"Stat\" : stat , \"Unit\" : str ( self . metric_unit ), # str(None) is desired, if no unit is specified \"Period\" : period , }, }, ], StartTime = start_time , EndTime = now , ) resp_status = response [ \"ResponseMetadata\" ][ \"HTTPStatusCode\" ] if resp_status != 200 : _LOGGER . error ( f \"Invalid response status code: { resp_status } \" ) return _LOGGER . debug ( f \"Response status code: { resp_status } \" ) return response def get_ec2_uptime ( self , ec2_instance_id : str , days : int , hours : int , minutes : int , ) -> int : \"\"\" Get the runtime of an EC2 instance Args: ec2_instance_id (str): the ID of the EC2 instance days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time Returns: int: the runtime of the EC2 instance in minutes \"\"\" if not self . is_ec2_running ( ec2_instance_id ): _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is not running anymore. \" f \"Uptime will be estimated based on reported metrics in \" f \"the last { days } days\" ) instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) # get the latest reported metric metrics_response = self . query_ec2_metrics ( days = days , hours = hours , minutes = minutes , stat = \"Maximum\" , # any stat works period = 60 , # most precise period that AWS stores for instances where # start time is between 3 hours and 15 days ago ) # extract the latest metric report time timed_metrics = self . timed_metric_factory ( metrics_response ) try : earliest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ 0 ] latest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ - 1 ] return ( earliest_metric_report_time - latest_metric_report_time ) . total_seconds () except IndexError : _LOGGER . warning ( f \"No metric data found for EC2: { self . dimension_value } \" ) return instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) for instance in instances : _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is still running. \" f \"Launch time: { instance . launch_time } \" ) return ( datetime . now ( pytz . utc ) - instance . launch_time ) . total_seconds () def is_ec2_running ( self , ec2_instance_id : str ) -> bool : \"\"\" Check if EC2 instance is running Args: ec2_instance_id (str): the ID of the EC2 instance Returns: bool: True if EC2 instance is running, False otherwise \"\"\" instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ ec2_instance_id ]}] ) if len ( list ( instances )) == 0 : return None if len ( list ( instances )) > 1 : raise Exception ( f \"Multiple EC2 instances matched by ID: { ec2_instance_id } \" ) for instance in instances : # check the status codes and their meanings: # https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501 if instance . state [ \"Code\" ] <= 16 : return True return False @staticmethod def timed_metric_factory ( response : dict ) -> List [ TimedMetric ]: \"\"\" Create a collection of TimedMetrics from the CloudWatch client response. Args: response (dict): the response from the query Returns: List[TimedMetric]: a collection of TimedMetrics \"\"\" return [ TimedMetric ( label = metric_data_result [ \"Label\" ], timestamps = metric_data_result [ \"Timestamps\" ], values = metric_data_result [ \"Values\" ], ) for metric_data_result in response [ \"MetricDataResults\" ] ] def _exec_timed_metric_handler ( self , handler_class : TimedMetricHandler , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ** kwargs , ) -> None : \"\"\" Internal method to execute a TimedMetricHandler Args: handler_class (TimedMetricHandler): the TimedMetricHandler to execute response (Optional[Dict]): the response from the query query_kwargs (Optional[Dict]): the query kwargs to use for the query **kwargs: additional kwargs to pass to the handler \"\"\" _LOGGER . debug ( f \"Executing ' { handler_class . __name__ } '\" ) response = response or self . query_ec2_metrics ( ** query_kwargs ) timed_metrics = self . timed_metric_factory ( response ) for timed_metric in timed_metrics : if len ( timed_metric . values ) < 1 : continue handler = handler_class ( timed_metric = timed_metric ) handler ( ** kwargs ) def _exec_response_handler ( self , handler_class : ResponseHandler , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ** kwargs , ) -> None : \"\"\" Internal method to execute a ResponseHandler Args: handler_class (ResponseHandler): the ResponseHandler to execute response (Optional[Dict]): the response from the query query_kwargs (Optional[Dict]): the query kwargs to use for the query **kwargs: additional kwargs to pass to the handler \"\"\" _LOGGER . debug ( f \"Executing ' { handler_class . __name__ } '\" ) response = response or self . query_ec2_metrics ( ** query_kwargs ) handler = handler_class ( response = response ) handler ( ** kwargs ) def save_metric_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a JSON file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricJsonSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def save_metric_csv ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a CSV file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricCsvSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def log_metric ( self , response : Optional [ Dict ] = None , query_preset : Optional [ str ] = None ): \"\"\" Query and log the metric data Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricLogger , target = None , # TODO: add support for saving to file response = response , ) def save_metric_plot ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and plot the metric data Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricPlotter , target = file_path , metric_unit = self . metric_unit , response = response , query_kwargs = query_kwargs , ) def log_metric_summary ( self , response : Optional [ Dict ] = None ): \"\"\" Query and summarize the metric data to a JSON file Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricSummarizer , target = None , # TODO: add support for saving to file metric_unit = self . metric_unit , summarizer = ( \"Max\" , max ), response = response , ) def save_response_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the response data to a JSON file Args: file_path (str): the file path to save the response data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseSaver , target = file_path , response = response , query_kwargs = query_kwargs , ) def log_response ( self , response : Optional [ Dict ] = None ): \"\"\" Query and log the response Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseLogger , target = None , response = response , )","title":"MetricWatcher"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.__init__","text":"Initialize MetricWatcher Parameters: Name Type Description Default namespace str the namespace of the metric required dimensions_list List [ Dict [ str , str ]] the dimensions of the metric required metric_name str the name of the metric required metric_id str the ID of the metric required metric_unit Optional [ str ] the unit of the metric None aws_access_key_id Optional [ str ] the AWS access key ID None aws_secret_access_key Optional [ str ] the AWS secret access key None aws_session_token Optional [ str ] the AWS session token None aws_region_name Optional [ str ] the AWS region name None Source code in cloudwatcher/metricwatcher.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , namespace : str , dimensions_list : List [ Dict [ str , str ]], metric_name : str , metric_id : str , metric_unit : Optional [ str ] = None , aws_access_key_id : Optional [ str ] = None , aws_secret_access_key : Optional [ str ] = None , aws_session_token : Optional [ str ] = None , aws_region_name : Optional [ str ] = None , ) -> None : \"\"\" Initialize MetricWatcher Args: namespace (str): the namespace of the metric dimensions_list (List[Dict[str, str]]): the dimensions of the metric metric_name (str): the name of the metric metric_id (str): the ID of the metric metric_unit (Optional[str]): the unit of the metric aws_access_key_id (Optional[str]): the AWS access key ID aws_secret_access_key (Optional[str]): the AWS secret access key aws_session_token (Optional[str]): the AWS session token aws_region_name (Optional[str]): the AWS region name \"\"\" super () . __init__ ( service_name = \"cloudwatch\" , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , aws_region_name = aws_region_name , ) self . namespace = namespace self . dimensions_list = dimensions_list self . metric_name = metric_name self . metric_id = metric_id self . metric_unit = metric_unit self . ec2_resource = boto3 . resource ( service_name = \"ec2\" , region_name = self . aws_region_name , aws_access_key_id = aws_access_key_id , aws_secret_access_key = aws_secret_access_key , aws_session_token = aws_session_token , )","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.get_ec2_uptime","text":"Get the runtime of an EC2 instance Parameters: Name Type Description Default ec2_instance_id str the ID of the EC2 instance required days int how many days to subtract from the current date to determine the metric collection start time required hours int how many hours to subtract from the current time to determine the metric collection start time required minutes int how many minutes to subtract from the current time to determine the metric collection start time required Returns: Name Type Description int int the runtime of the EC2 instance in minutes Source code in cloudwatcher/metricwatcher.py 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def get_ec2_uptime ( self , ec2_instance_id : str , days : int , hours : int , minutes : int , ) -> int : \"\"\" Get the runtime of an EC2 instance Args: ec2_instance_id (str): the ID of the EC2 instance days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time Returns: int: the runtime of the EC2 instance in minutes \"\"\" if not self . is_ec2_running ( ec2_instance_id ): _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is not running anymore. \" f \"Uptime will be estimated based on reported metrics in \" f \"the last { days } days\" ) instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) # get the latest reported metric metrics_response = self . query_ec2_metrics ( days = days , hours = hours , minutes = minutes , stat = \"Maximum\" , # any stat works period = 60 , # most precise period that AWS stores for instances where # start time is between 3 hours and 15 days ago ) # extract the latest metric report time timed_metrics = self . timed_metric_factory ( metrics_response ) try : earliest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ 0 ] latest_metric_report_time = timed_metrics [ - 1 ] . timestamps [ - 1 ] return ( earliest_metric_report_time - latest_metric_report_time ) . total_seconds () except IndexError : _LOGGER . warning ( f \"No metric data found for EC2: { self . dimension_value } \" ) return instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ self . dimension_value ]}] ) for instance in instances : _LOGGER . info ( f \"Instance ' { self . dimension_value } ' is still running. \" f \"Launch time: { instance . launch_time } \" ) return ( datetime . now ( pytz . utc ) - instance . launch_time ) . total_seconds ()","title":"get_ec2_uptime()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.is_ec2_running","text":"Check if EC2 instance is running Parameters: Name Type Description Default ec2_instance_id str the ID of the EC2 instance required Returns: Name Type Description bool bool True if EC2 instance is running, False otherwise Source code in cloudwatcher/metricwatcher.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def is_ec2_running ( self , ec2_instance_id : str ) -> bool : \"\"\" Check if EC2 instance is running Args: ec2_instance_id (str): the ID of the EC2 instance Returns: bool: True if EC2 instance is running, False otherwise \"\"\" instances = self . ec2_resource . instances . filter ( Filters = [{ \"Name\" : \"instance-id\" , \"Values\" : [ ec2_instance_id ]}] ) if len ( list ( instances )) == 0 : return None if len ( list ( instances )) > 1 : raise Exception ( f \"Multiple EC2 instances matched by ID: { ec2_instance_id } \" ) for instance in instances : # check the status codes and their meanings: # https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501 if instance . state [ \"Code\" ] <= 16 : return True return False","title":"is_ec2_running()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_metric","text":"Query and log the metric data Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query None Source code in cloudwatcher/metricwatcher.py 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 def log_metric ( self , response : Optional [ Dict ] = None , query_preset : Optional [ str ] = None ): \"\"\" Query and log the metric data Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricLogger , target = None , # TODO: add support for saving to file response = response , )","title":"log_metric()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_metric_summary","text":"Query and summarize the metric data to a JSON file Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def log_metric_summary ( self , response : Optional [ Dict ] = None ): \"\"\" Query and summarize the metric data to a JSON file Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricSummarizer , target = None , # TODO: add support for saving to file metric_unit = self . metric_unit , summarizer = ( \"Max\" , max ), response = response , )","title":"log_metric_summary()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_response","text":"Query and log the response Parameters: Name Type Description Default response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 410 411 412 413 414 415 416 417 418 419 420 421 422 def log_response ( self , response : Optional [ Dict ] = None ): \"\"\" Query and log the response Args: response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseLogger , target = None , response = response , )","title":"log_response()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.query_ec2_metrics","text":"Query EC2 metrics Parameters: Name Type Description Default days int how many days to subtract from the current date to determine the metric collection start time required hours int how many hours to subtract from the current time to determine the metric collection start time required minutes int how many minutes to subtract from the current time to determine the metric collection start time required stat str the statistic to query required period int the period of the metric required Returns: Name Type Description Dict Dict the response from the query, check the structure of the Dict response here # noqa: E501 Source code in cloudwatcher/metricwatcher.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def query_ec2_metrics ( self , days : int , hours : int , minutes : int , stat : str , period : int , ) -> Dict : \"\"\" Query EC2 metrics Args: days (int): how many days to subtract from the current date to determine the metric collection start time hours (int): how many hours to subtract from the current time to determine the metric collection start time minutes (int): how many minutes to subtract from the current time to determine the metric collection start time stat (str): the statistic to query period (int): the period of the metric Returns: Dict: the response from the query, check the structure of the response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501 \"\"\" # Create CloudWatch client now = datetime . datetime . now ( pytz . utc ) start_time = now - datetime . timedelta ( days = days , hours = hours , minutes = minutes ) _time = lambda x : x . strftime ( \"%Y-%m- %d %H:%M:%S\" ) _LOGGER . info ( f \"Querying ' { self . metric_name } ' for dimensions { self . dimensions_list } \" f \"from { _time ( start_time ) } to { _time ( now ) } \" ) response = self . client . get_metric_data ( MetricDataQueries = [ { \"Id\" : self . metric_id , \"MetricStat\" : { \"Metric\" : { \"Namespace\" : self . namespace , \"MetricName\" : self . metric_name , \"Dimensions\" : [ dim . dict () for dim in self . dimensions_list ], }, \"Stat\" : stat , \"Unit\" : str ( self . metric_unit ), # str(None) is desired, if no unit is specified \"Period\" : period , }, }, ], StartTime = start_time , EndTime = now , ) resp_status = response [ \"ResponseMetadata\" ][ \"HTTPStatusCode\" ] if resp_status != 200 : _LOGGER . error ( f \"Invalid response status code: { resp_status } \" ) return _LOGGER . debug ( f \"Response status code: { resp_status } \" ) return response","title":"query_ec2_metrics()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_csv","text":"Query and save the metric data to a CSV file Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 def save_metric_csv ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a CSV file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricCsvSaver , target = file_path , response = response , query_kwargs = query_kwargs , )","title":"save_metric_csv()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_json","text":"Query and save the metric data to a JSON file Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def save_metric_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the metric data to a JSON file Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricJsonSaver , target = file_path , response = response , query_kwargs = query_kwargs , )","title":"save_metric_json()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_plot","text":"Query and plot the metric data Parameters: Name Type Description Default file_path str the file path to save the metric data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 def save_metric_plot ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and plot the metric data Args: file_path (str): the file path to save the metric data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_timed_metric_handler ( TimedMetricPlotter , target = file_path , metric_unit = self . metric_unit , response = response , query_kwargs = query_kwargs , )","title":"save_metric_plot()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_response_json","text":"Query and save the response data to a JSON file Parameters: Name Type Description Default file_path str the file path to save the response data to required response Optional [ Dict ] the response from the query None query_preset Optional [ str ] the query preset to use for the query required Source code in cloudwatcher/metricwatcher.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 def save_response_json ( self , file_path : str , response : Optional [ Dict ] = None , query_kwargs : Optional [ Dict ] = None , ): \"\"\" Query and save the response data to a JSON file Args: file_path (str): the file path to save the response data to response (Optional[Dict]): the response from the query query_preset (Optional[str]): the query preset to use for the query \"\"\" self . _exec_response_handler ( ResponseSaver , target = file_path , response = response , query_kwargs = query_kwargs , )","title":"save_response_json()"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.timed_metric_factory","text":"Create a collection of TimedMetrics from the CloudWatch client response. Parameters: Name Type Description Default response dict the response from the query required Returns: Type Description List [ TimedMetric ] List[TimedMetric]: a collection of TimedMetrics Source code in cloudwatcher/metricwatcher.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 @staticmethod def timed_metric_factory ( response : dict ) -> List [ TimedMetric ]: \"\"\" Create a collection of TimedMetrics from the CloudWatch client response. Args: response (dict): the response from the query Returns: List[TimedMetric]: a collection of TimedMetrics \"\"\" return [ TimedMetric ( label = metric_data_result [ \"Label\" ], timestamps = metric_data_result [ \"Timestamps\" ], values = metric_data_result [ \"Values\" ], ) for metric_data_result in response [ \"MetricDataResults\" ] ]","title":"timed_metric_factory()"},{"location":"API_documentation/#metricwatchersetup","text":"A class for the setup of the MetricWatcher Source code in cloudwatcher/preset.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 @dataclass class MetricWatcherSetup : \"\"\" A class for the setup of the MetricWatcher \"\"\" namespace : str dimensions_list : List [ Dimension ] metric_name : str metric_id : str metric_unit : str aws_access_key_id : str = None aws_secret_access_key : str = None aws_session_token : str = None aws_region_name : str = None def __post_init__ ( self ): self . aws_access_key_id = self . aws_access_key_id or os . environ . get ( \"AWS_ACCESS_KEY_ID\" ) self . aws_secret_access_key = self . aws_secret_access_key or os . environ . get ( \"AWS_SECRET_ACCESS_KEY\" ) self . aws_session_token = self . aws_session_token or os . environ . get ( \"AWS_SESSION_TOKEN\" ) self . aws_region_name = self . aws_region_name or os . environ . get ( \"AWS_DEFAULT_REGION\" ) self . dimensions_list = [ Dimension ( ** dimension ) for dimension in self . dimensions_list ] @classmethod def from_dict ( cls , data : dict ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a dictionary Args: data (dict): The dictionary to use \"\"\" return cls ( ** data ) @classmethod def from_json ( cls , file_path : str ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a JSON file Args: file_path (str): The path to the JSON file \"\"\" with open ( file_path ) as f : data = json . load ( f ) return cls . from_dict ( data ) def to_dict ( self ) -> dict : \"\"\" Convert the MetricWatcherSetup object to a dictionary Returns: dict: The dictionary representation of the object \"\"\" return self . __dict__ def upsert_dimensions ( self , dimensions_specs : List [ str ] = None ): \"\"\" Upsert the dimensions list with the dimensions specified in the environment Args: dimensions_spec (List[str]): A list of strings in the format of \"Name:Value\" \"\"\" if dimensions_specs is None : return for dimension_spec in dimensions_specs : name , value = dimension_spec . split ( \":\" ) for dimension in self . dimensions_list : if dimension . Name == name : dimension . Value = value break else : self . dimensions_list . append ( Dimension ( Name = name , Value = value ))","title":"MetricWatcherSetup"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.from_dict","text":"Create a MetricWatcherSetup object from a dictionary Parameters: Name Type Description Default data dict The dictionary to use required Source code in cloudwatcher/preset.py 161 162 163 164 165 166 167 168 169 @classmethod def from_dict ( cls , data : dict ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a dictionary Args: data (dict): The dictionary to use \"\"\" return cls ( ** data )","title":"from_dict()"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.from_json","text":"Create a MetricWatcherSetup object from a JSON file Parameters: Name Type Description Default file_path str The path to the JSON file required Source code in cloudwatcher/preset.py 171 172 173 174 175 176 177 178 179 180 181 @classmethod def from_json ( cls , file_path : str ) -> \"MetricWatcherSetup\" : \"\"\" Create a MetricWatcherSetup object from a JSON file Args: file_path (str): The path to the JSON file \"\"\" with open ( file_path ) as f : data = json . load ( f ) return cls . from_dict ( data )","title":"from_json()"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.to_dict","text":"Convert the MetricWatcherSetup object to a dictionary Returns: Name Type Description dict dict The dictionary representation of the object Source code in cloudwatcher/preset.py 183 184 185 186 187 188 189 190 def to_dict ( self ) -> dict : \"\"\" Convert the MetricWatcherSetup object to a dictionary Returns: dict: The dictionary representation of the object \"\"\" return self . __dict__","title":"to_dict()"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.upsert_dimensions","text":"Upsert the dimensions list with the dimensions specified in the environment Parameters: Name Type Description Default dimensions_spec List [ str ] A list of strings in the format of \"Name:Value\" required Source code in cloudwatcher/preset.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def upsert_dimensions ( self , dimensions_specs : List [ str ] = None ): \"\"\" Upsert the dimensions list with the dimensions specified in the environment Args: dimensions_spec (List[str]): A list of strings in the format of \"Name:Value\" \"\"\" if dimensions_specs is None : return for dimension_spec in dimensions_specs : name , value = dimension_spec . split ( \":\" ) for dimension in self . dimensions_list : if dimension . Name == name : dimension . Value = value break else : self . dimensions_list . append ( Dimension ( Name = name , Value = value ))","title":"upsert_dimensions()"},{"location":"API_documentation/#presetfilesinventory","text":"Source code in cloudwatcher/preset.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class PresetFilesInventory : def __init__ ( self , presets_dir : Union [ Path , str ] = None ) -> None : \"\"\" Initialize the preset inventory Args: presets_dir (Path): The path to the presets directory Raises: ValueError: If the presets directory does not exist \"\"\" preset_dir = ( Path ( presets_dir ) if presets_dir is not None else Path ( __file__ ) . parent / \"presets\" ) if not preset_dir . exists (): raise ValueError ( f \"Presets directory { preset_dir } does not exist\" ) self . _presets_dir = preset_dir _LOGGER . debug ( f \"Presets directory: { self . presets_dir } \" ) self . _presets = self . _get_available_presets ( self . presets_dir ) def _get_available_presets ( self , presets_dir : Path ) -> List [ str ]: return { preset_file . stem : preset_file for preset_file in presets_dir . iterdir () if preset_file . is_file () and preset_file . suffix == \".json\" } @property def presets_table ( self ) -> Table : \"\"\" Get a rich table with the available presets Returns: Table: The rich table \"\"\" table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( \"Name\" ) table . add_column ( \"Path\" , style = \"dim\" ) for preset_name , preset_path in self . presets . items (): table . add_row ( preset_name , preset_path . as_posix ()) table . title = f \"Presets available in: { self . presets_dir } \" return table @property def presets ( self ) -> Dict [ str , Path ]: \"\"\" Get the available presets Returns: Dict[str, Path]: The available presets \"\"\" return self . _presets @property def presets_list ( self ) -> List [ str ]: \"\"\" Get the list of available presets Returns: List[str]: The list of available presets \"\"\" return list ( self . _presets . keys ()) @property def presets_dir ( self ) -> Path : \"\"\" Get the presets directory Returns: Path: The presets directory \"\"\" return self . _presets_dir def get_preset_path ( self , preset_name : str ) -> Path : \"\"\" Get the preset file content Args: preset_name (str): The name of the preset Returns: Path: the path to the preset file \"\"\" if preset_name not in self . presets : raise ValueError ( f \"Preset { preset_name } not found. Available presets: \" f \" { ', ' . join ( self . presets . keys ()) } \" ) return self . presets [ preset_name ]","title":"PresetFilesInventory"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.__init__","text":"Initialize the preset inventory Parameters: Name Type Description Default presets_dir Path The path to the presets directory None Raises: Type Description ValueError If the presets directory does not exist Source code in cloudwatcher/preset.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def __init__ ( self , presets_dir : Union [ Path , str ] = None ) -> None : \"\"\" Initialize the preset inventory Args: presets_dir (Path): The path to the presets directory Raises: ValueError: If the presets directory does not exist \"\"\" preset_dir = ( Path ( presets_dir ) if presets_dir is not None else Path ( __file__ ) . parent / \"presets\" ) if not preset_dir . exists (): raise ValueError ( f \"Presets directory { preset_dir } does not exist\" ) self . _presets_dir = preset_dir _LOGGER . debug ( f \"Presets directory: { self . presets_dir } \" ) self . _presets = self . _get_available_presets ( self . presets_dir )","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.get_preset_path","text":"Get the preset file content Parameters: Name Type Description Default preset_name str The name of the preset required Returns: Name Type Description Path Path the path to the preset file Source code in cloudwatcher/preset.py 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def get_preset_path ( self , preset_name : str ) -> Path : \"\"\" Get the preset file content Args: preset_name (str): The name of the preset Returns: Path: the path to the preset file \"\"\" if preset_name not in self . presets : raise ValueError ( f \"Preset { preset_name } not found. Available presets: \" f \" { ', ' . join ( self . presets . keys ()) } \" ) return self . presets [ preset_name ]","title":"get_preset_path()"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets","text":"Get the available presets Returns: Type Description Dict [ str , Path ] Dict[str, Path]: The available presets Source code in cloudwatcher/preset.py 61 62 63 64 65 66 67 68 69 @property def presets ( self ) -> Dict [ str , Path ]: \"\"\" Get the available presets Returns: Dict[str, Path]: The available presets \"\"\" return self . _presets","title":"presets()"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_dir","text":"Get the presets directory Returns: Name Type Description Path Path The presets directory Source code in cloudwatcher/preset.py 81 82 83 84 85 86 87 88 89 @property def presets_dir ( self ) -> Path : \"\"\" Get the presets directory Returns: Path: The presets directory \"\"\" return self . _presets_dir","title":"presets_dir()"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_list","text":"Get the list of available presets Returns: Type Description List [ str ] List[str]: The list of available presets Source code in cloudwatcher/preset.py 71 72 73 74 75 76 77 78 79 @property def presets_list ( self ) -> List [ str ]: \"\"\" Get the list of available presets Returns: List[str]: The list of available presets \"\"\" return list ( self . _presets . keys ())","title":"presets_list()"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_table","text":"Get a rich table with the available presets Returns: Name Type Description Table Table The rich table Source code in cloudwatcher/preset.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @property def presets_table ( self ) -> Table : \"\"\" Get a rich table with the available presets Returns: Table: The rich table \"\"\" table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( \"Name\" ) table . add_column ( \"Path\" , style = \"dim\" ) for preset_name , preset_path in self . presets . items (): table . add_row ( preset_name , preset_path . as_posix ()) table . title = f \"Presets available in: { self . presets_dir } \" return table","title":"presets_table()"},{"location":"API_documentation/#metric-handlers","text":"","title":"Metric handlers"},{"location":"API_documentation/#cloudwatcher.metric_handlers.Handler","text":"Bases: ABC Abstract class to establish the interface for data handling Source code in cloudwatcher/metric_handlers.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 class Handler ( ABC ): \"\"\" Abstract class to establish the interface for data handling \"\"\" @abstractmethod def __init__ ( self , response : dict , logger : logging . Logger ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API logger (logging.Logger): The logger to use \"\"\" pass @abstractmethod def __call__ ( self , target : str ) -> None : \"\"\" Execute the handler Args: target (str): The target to use for the handler \"\"\" pass","title":"Handler"},{"location":"API_documentation/#cloudwatcher.metric_handlers.Handler.__call__","text":"Execute the handler Parameters: Name Type Description Default target str The target to use for the handler required Source code in cloudwatcher/metric_handlers.py 80 81 82 83 84 85 86 87 88 @abstractmethod def __call__ ( self , target : str ) -> None : \"\"\" Execute the handler Args: target (str): The target to use for the handler \"\"\" pass","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.Handler.__init__","text":"Initialize the handler Parameters: Name Type Description Default response dict The response from the AWS API required logger logging . Logger The logger to use required Source code in cloudwatcher/metric_handlers.py 69 70 71 72 73 74 75 76 77 78 @abstractmethod def __init__ ( self , response : dict , logger : logging . Logger ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API logger (logging.Logger): The logger to use \"\"\" pass","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseHandler","text":"Bases: Handler Abstract class to establish the interface for a response handling Source code in cloudwatcher/metric_handlers.py 91 92 93 94 95 96 97 98 99 100 101 102 103 class ResponseHandler ( Handler ): \"\"\" Abstract class to establish the interface for a response handling \"\"\" def __init__ ( self , response : dict ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API \"\"\" self . response = response","title":"ResponseHandler"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseHandler.__init__","text":"Initialize the handler Parameters: Name Type Description Default response dict The response from the AWS API required Source code in cloudwatcher/metric_handlers.py 96 97 98 99 100 101 102 103 def __init__ ( self , response : dict ) -> None : \"\"\" Initialize the handler Args: response (dict): The response from the AWS API \"\"\" self . response = response","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseLogger","text":"Bases: ResponseHandler Log the response to the console Source code in cloudwatcher/metric_handlers.py 138 139 140 141 142 143 144 145 146 147 148 class ResponseLogger ( ResponseHandler ): \"\"\" Log the response to the console \"\"\" def __call__ ( self , target : str ) -> None : if target is not None : raise NotImplementedError ( \"Logging responses to a file is not yet implemented.\" ) _LOGGER . debug ( json . dumps ( self . response , indent = 4 , default = str ))","title":"ResponseLogger"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseSaver","text":"Bases: ResponseHandler Save the response to a file Source code in cloudwatcher/metric_handlers.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 class ResponseSaver ( ResponseHandler ): \"\"\" Save the response to a file \"\"\" def __call__ ( self , target : str ) -> None : \"\"\" Save the response to a file Args: target (str): The target file to save the response to \"\"\" with open ( target , \"w\" ) as f : json . dump ( self . response , f , indent = 4 , default = str ) _LOGGER . info ( f \"Saved response to: { target } \" )","title":"ResponseSaver"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseSaver.__call__","text":"Save the response to a file Parameters: Name Type Description Default target str The target file to save the response to required Source code in cloudwatcher/metric_handlers.py 126 127 128 129 130 131 132 133 134 135 def __call__ ( self , target : str ) -> None : \"\"\" Save the response to a file Args: target (str): The target file to save the response to \"\"\" with open ( target , \"w\" ) as f : json . dump ( self . response , f , indent = 4 , default = str ) _LOGGER . info ( f \"Saved response to: { target } \" )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetric","text":"Timed metric object Parameters: Name Type Description Default timestamps List [ datetime ] The timestamps of the metric required values List [ float ] The values of the metric required label str The label of the metric required Source code in cloudwatcher/metric_handlers.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @dataclass class TimedMetric : \"\"\" Timed metric object Args: timestamps (List[datetime]): The timestamps of the metric values (List[float]): The values of the metric label (str): The label of the metric \"\"\" label : str timestamps : List [ datetime ] values : List [ str ] def __len__ ( self ): if len ( self . timestamps ) == len ( self . values ): return len ( self . values ) raise ValueError ( \"The internal timed metric lengths are not equal\" )","title":"TimedMetric"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricCsvSaver","text":"Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 class TimedMetricCsvSaver ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a csv file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" , encoding = \"UTF8\" , newline = \"\" ) as f : writer = csv . writer ( f ) # write the header writer . writerow ([ \"time\" , \"value\" ]) # write the data for i in range ( len ( self . timed_metric )): writer . writerow ( [ self . timed_metric . timestamps [ i ], self . timed_metric . values [ i ]] ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" )","title":"TimedMetricCsvSaver"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricCsvSaver.__call__","text":"Write the object to a csv file Parameters: Name Type Description Default target str The target file to save the object to required Source code in cloudwatcher/metric_handlers.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a csv file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" , encoding = \"UTF8\" , newline = \"\" ) as f : writer = csv . writer ( f ) # write the header writer . writerow ([ \"time\" , \"value\" ]) # write the data for i in range ( len ( self . timed_metric )): writer . writerow ( [ self . timed_metric . timestamps [ i ], self . timed_metric . values [ i ]] ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricHandler","text":"Bases: Handler Class to establish the interface for a timed metric handling Source code in cloudwatcher/metric_handlers.py 106 107 108 109 110 111 112 113 114 115 116 117 118 class TimedMetricHandler ( Handler ): \"\"\" Class to establish the interface for a timed metric handling \"\"\" def __init__ ( self , timed_metric : TimedMetric ) -> None : \"\"\" Initialize the handler Args: timed_metric (TimedMetric): The timed metric to use \"\"\" self . timed_metric = timed_metric","title":"TimedMetricHandler"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricHandler.__init__","text":"Initialize the handler Parameters: Name Type Description Default timed_metric TimedMetric The timed metric to use required Source code in cloudwatcher/metric_handlers.py 111 112 113 114 115 116 117 118 def __init__ ( self , timed_metric : TimedMetric ) -> None : \"\"\" Initialize the handler Args: timed_metric (TimedMetric): The timed metric to use \"\"\" self . timed_metric = timed_metric","title":"__init__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricJsonSaver","text":"Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 class TimedMetricJsonSaver ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a json file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" ) as f : json . dump ( { \"Label\" : self . timed_metric . label , \"Timestamps\" : self . timed_metric . timestamps , \"Values\" : self . timed_metric . values , }, f , indent = 4 , default = str , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" )","title":"TimedMetricJsonSaver"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricJsonSaver.__call__","text":"Write the object to a json file Parameters: Name Type Description Default target str The target file to save the object to required Source code in cloudwatcher/metric_handlers.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 def __call__ ( self , target : str ) -> None : \"\"\" Write the object to a json file Args: target (str): The target file to save the object to \"\"\" with open ( target , \"w\" ) as f : json . dump ( { \"Label\" : self . timed_metric . label , \"Timestamps\" : self . timed_metric . timestamps , \"Values\" : self . timed_metric . values , }, f , indent = 4 , default = str , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' data to: { target } \" )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger","text":"Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 class TimedMetricLogger ( TimedMetricHandler ): def __call__ ( self , target : str ) -> None : \"\"\" Log the timed metric as a table \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( f \"Time ( { str ( pytz . utc ) } )\" , style = \"dim\" , justify = \"center\" ) table . add_column ( \"Value\" ) values = [ self . mem_to_str ( v ) if self . timed_metric . label . startswith ( \"mem\" ) else str ( v ) for v in self . timed_metric . values ] for i in range ( len ( self . timed_metric . timestamps )): table . add_row ( self . timed_metric . timestamps [ i ] . strftime ( \"%H:%M:%S\" ), values [ i ] ) console = Console () console . print ( table ) @staticmethod def mem_to_str ( size : int , precision : int = 3 ) -> str : \"\"\" Convert bytes to human readable string Args: size (int): The size in bytes precision (int): The precision to use, number of decimal places Returns: str: The human readable string \"\"\" size , suffix = convert_mem ( size ) return \" %.*f %s \" % ( precision , size , suffix )","title":"TimedMetricLogger"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger.__call__","text":"Log the timed metric as a table Source code in cloudwatcher/metric_handlers.py 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def __call__ ( self , target : str ) -> None : \"\"\" Log the timed metric as a table \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) table = Table ( show_header = True , header_style = \"bold magenta\" ) table . add_column ( f \"Time ( { str ( pytz . utc ) } )\" , style = \"dim\" , justify = \"center\" ) table . add_column ( \"Value\" ) values = [ self . mem_to_str ( v ) if self . timed_metric . label . startswith ( \"mem\" ) else str ( v ) for v in self . timed_metric . values ] for i in range ( len ( self . timed_metric . timestamps )): table . add_row ( self . timed_metric . timestamps [ i ] . strftime ( \"%H:%M:%S\" ), values [ i ] ) console = Console () console . print ( table )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger.mem_to_str","text":"Convert bytes to human readable string Parameters: Name Type Description Default size int The size in bytes required precision int The precision to use, number of decimal places 3 Returns: Name Type Description str str The human readable string Source code in cloudwatcher/metric_handlers.py 244 245 246 247 248 249 250 251 252 253 254 255 256 257 @staticmethod def mem_to_str ( size : int , precision : int = 3 ) -> str : \"\"\" Convert bytes to human readable string Args: size (int): The size in bytes precision (int): The precision to use, number of decimal places Returns: str: The human readable string \"\"\" size , suffix = convert_mem ( size ) return \" %.*f %s \" % ( precision , size , suffix )","title":"mem_to_str()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricPlotter","text":"Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class TimedMetricPlotter ( TimedMetricHandler ): def __call__ ( self , target : str , metric_unit : str ) -> None : \"\"\" Plot the timed metric Args: target (str): The target file to save the plot to metric_unit (str): The unit of the metric \"\"\" values = self . timed_metric . values if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : metric_unit = \"GB\" values = [ convert_mem ( v , force_suffix = metric_unit )[ 0 ] for v in values ] plt . plot ( self . timed_metric . timestamps , values , linewidth = 0.8 , ) plt . title ( f \" { self . timed_metric . label } over time\" , loc = \"right\" , fontstyle = \"italic\" , ) plt . ylabel ( f \" { self . timed_metric . label } ( { metric_unit } )\" ) plt . ticklabel_format ( axis = \"y\" , style = \"plain\" , useOffset = False ) plt . tick_params ( left = True , bottom = False , labelleft = True , labelbottom = False ) plt . savefig ( target , bbox_inches = \"tight\" , pad_inches = 0.1 , dpi = 300 , format = \"png\" , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' plot to: { target } \" )","title":"TimedMetricPlotter"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricPlotter.__call__","text":"Plot the timed metric Parameters: Name Type Description Default target str The target file to save the plot to required metric_unit str The unit of the metric required Source code in cloudwatcher/metric_handlers.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def __call__ ( self , target : str , metric_unit : str ) -> None : \"\"\" Plot the timed metric Args: target (str): The target file to save the plot to metric_unit (str): The unit of the metric \"\"\" values = self . timed_metric . values if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : metric_unit = \"GB\" values = [ convert_mem ( v , force_suffix = metric_unit )[ 0 ] for v in values ] plt . plot ( self . timed_metric . timestamps , values , linewidth = 0.8 , ) plt . title ( f \" { self . timed_metric . label } over time\" , loc = \"right\" , fontstyle = \"italic\" , ) plt . ylabel ( f \" { self . timed_metric . label } ( { metric_unit } )\" ) plt . ticklabel_format ( axis = \"y\" , style = \"plain\" , useOffset = False ) plt . tick_params ( left = True , bottom = False , labelleft = True , labelbottom = False ) plt . savefig ( target , bbox_inches = \"tight\" , pad_inches = 0.1 , dpi = 300 , format = \"png\" , ) _LOGGER . info ( f \"Saved ' { self . timed_metric . label } ' plot to: { target } \" )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricSummarizer","text":"Bases: TimedMetricHandler Source code in cloudwatcher/metric_handlers.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 class TimedMetricSummarizer ( TimedMetricHandler ): def __call__ ( self , target : str , metric_unit : str , summarizer : Tuple [ str , callable ], ) -> None : \"\"\" Summarize the metric Args: target (str): The target file to save the summary to metric_unit (str): The unit of the metric summarizer (Tuple[str, callable]): The summarizer to use and the function to use \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) timespan = self . timed_metric . timestamps [ 0 ] - self . timed_metric . timestamps [ - 1 ] _LOGGER . info ( f \"Retrieved ' { self . timed_metric . label } ' { len ( self . timed_metric . values ) } \" f \"measurements over { timespan } timespan\" ) summary = summarizer [ 1 ]( self . timed_metric . values ) if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : mem , metric_unit = convert_mem ( summary ) _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { mem : .2f } { metric_unit } over { timespan } timespan\" ) else : _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { summary } over { timespan } timespan\" )","title":"TimedMetricSummarizer"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricSummarizer.__call__","text":"Summarize the metric Parameters: Name Type Description Default target str The target file to save the summary to required metric_unit str The unit of the metric required summarizer Tuple [ str , callable ] The summarizer to use and the function to use required Source code in cloudwatcher/metric_handlers.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 def __call__ ( self , target : str , metric_unit : str , summarizer : Tuple [ str , callable ], ) -> None : \"\"\" Summarize the metric Args: target (str): The target file to save the summary to metric_unit (str): The unit of the metric summarizer (Tuple[str, callable]): The summarizer to use and the function to use \"\"\" if target is not None : raise NotImplementedError ( \"Logging to a file is not yet implemented.\" ) timespan = self . timed_metric . timestamps [ 0 ] - self . timed_metric . timestamps [ - 1 ] _LOGGER . info ( f \"Retrieved ' { self . timed_metric . label } ' { len ( self . timed_metric . values ) } \" f \"measurements over { timespan } timespan\" ) summary = summarizer [ 1 ]( self . timed_metric . values ) if self . timed_metric . label . startswith ( \"mem\" ) and metric_unit == \"Bytes\" : mem , metric_unit = convert_mem ( summary ) _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { mem : .2f } { metric_unit } over { timespan } timespan\" ) else : _LOGGER . info ( f \" { summarizer [ 0 ] } ' { self . timed_metric . label } ' is \" f \" { summary } over { timespan } timespan\" )","title":"__call__()"},{"location":"API_documentation/#cloudwatcher.metric_handlers.convert_mem","text":"Convert memory in bytes to the highest possible, or desired memory unit Parameters: Name Type Description Default value int The memory in bytes required force_suffix str The desired memory unit None Returns: Type Description Tuple [ float , str ] Tuple[float, str]: The memory in the desired unit and the unit Source code in cloudwatcher/metric_handlers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 def convert_mem ( value : int , force_suffix : str = None ) -> Tuple [ float , str ]: \"\"\" Convert memory in bytes to the highest possible, or desired memory unit Args: value (int): The memory in bytes force_suffix (str): The desired memory unit Returns: Tuple[float, str]: The memory in the desired unit and the unit \"\"\" suffixes = [ \"B\" , \"KB\" , \"MB\" , \"GB\" , \"TB\" ] if force_suffix is not None : try : idx = suffixes . index ( force_suffix ) except ValueError : raise ValueError ( f \"Forced memory unit must me one of: { suffixes } \" ) else : return value / float ( pow ( 1024 , idx )), force_suffix suffixIndex = 0 while value > 1024 and suffixIndex < len ( suffixes ) - 1 : suffixIndex += 1 value = value / 1024.0 return value , suffixes [ suffixIndex ]","title":"convert_mem()"},{"location":"API_usage/","text":"cloudwatcher Python API usage The purpose of this page is to provide a quick overview of the cloudwatcher Python API. The package consists of two user-facing classes: MetricWatcher : This class is used to interact with AWS CloudWatch metrics. LogWatcher : This class is used to interact with AWS CloudWatch logs. Both of these classes inherit from the CloudWatcher class. MetricWatcher : convenient interface to AWS CloudWatch metrics MetricWatcher can be used to interact with AWS CloudWatch metrics. MetricWatcher initialization As described in the Login credentials section, the AWS credentials can be sourced from environment variables: AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , AWS_SESSION_TOKEN . Alternatively, you can pass the values as arguments to the MetricWatcher constructor. from cloudwatcher.metricwatcher import MetricWatcher from cloudwatcher.preset import Dimension from dotenv import load_dotenv import os load_dotenv () instance_id = os . environ . get ( \"INSTANCE_ID\" ) mw = MetricWatcher ( namespace = \"NepheleNamespaceEC2\" , metric_name = \"mem_used\" , metric_id = \"mem_used\" , metric_unit = \"Bytes\" , dimensions_list = [ Dimension ( Name = \"InstanceId\" , Value = instance_id )], ) MetricWatcher presets As you can see there are multiple arguments that can be passed to the MetricWatcher constructor. In order to improve the UX when using MetricWatcher . The cloudwatcher package provides a few presets that can be used to query the data reported by CloudWatchAgent within certain systems. Additionally, custom presets can be defined by the user and used in the same way. Presets are JSON-formatted files that provide parameter bundles for MetricWatcher initialization. Usage Listing available presets: from cloudwatcher.preset import PresetFilesInventory from rich.console import Console pfi = PresetFilesInventory () Console () . print ( pfi . presets_table ) Presets available in: /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Path \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 nephele_disk_used_percent \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502 \u2502 nephele_mem_cached \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502 \u2502 nephele_mem \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502 \u2502 nephele_disk_used_percent_nephele_data \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502 \u2502 nephele_cpu_usage_user \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_cp\u2026 \u2502 \u2502 nephele_processes_dead \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_pr\u2026 \u2502 \u2502 nephele_swap_used_percent \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502 \u2502 nephele_swap_used \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Using a preset: from cloudwatcher.preset import MetricWatcherSetup mw_setup = MetricWatcherSetup . from_json ( pfi . get_preset_path ( \"nephele_mem\" )) mw_setup . upsert_dimensions ([ f \"InstanceId: { instance_id } \" ]) mw = MetricWatcher ( ** mw_setup . to_dict ()) query_kwargs = { \"days\" : 5 , \"hours\" : 0 , \"minutes\" : 0 , \"stat\" : \"Maximum\" , \"period\" : 60 , } response = mw . query_ec2_metrics ( ** query_kwargs ) Querying AWS CloudWatch metrics In order to specify the EC2 instace query settings (period, granularity, etc.), the user would need to provide multiple parameters. To make it easier, there are a few sensible presets that can be used to select the query settings, which are passed to query_ec2_metrics method. These presets are defined to query the data reported by CloudWatchAgent within the last day, hour or minute. The presets can be used by passing the query_preset argument to the functions presented below. Alternatively, users can pass query_kwargs argument, which overrides the preset values. Logging methods There is a method that can be used to log the metric to the screen. The EC2 instance is automatically queried if the query response is not provided. File saving methods There are number of methods that can be used to save the metric data to a file. Again, the EC2 instance is automatically queried if the query response is not provided. mw . save_metric_plot ( file_path = f \"/tmp/ { instance_id } _plot.png\" , query_kwargs = query_kwargs ) mw . save_metric_csv ( file_path = f \"/tmp/ { instance_id } _metric.csv\" , query_kwargs = query_kwargs ) mw . save_metric_json ( file_path = f \"/tmp/ { instance_id } _metric.json\" , query_kwargs = query_kwargs ) mw . save_response_json ( file_path = f \"/tmp/ { instance_id } _response.json\" , query_kwargs = query_kwargs ) Manual EC2 querying For users that require more control over the EC2 instance query settings, the query_ec2_metrics method can be used to manually query the EC2 instance. For instance it allows to fine tune the query period settings. FINE_TUNED_SETTINGS = { \"days\" : 5 , \"hours\" : 0 , \"minutes\" : 0 , \"stat\" : \"Maximum\" , \"period\" : 60 , } response = mw . query_ec2_metrics ( ** FINE_TUNED_SETTINGS ) response [ \"ResponseMetadata\" ] {'RequestId': 'bb3880e0-17e6-45d2-a007-a7b797c6d52f', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'bb3880e0-17e6-45d2-a007-a7b797c6d52f', 'content-type': 'text/xml', 'content-length': '33663', 'date': 'Tue, 08 Nov 2022 16:46:07 GMT'}, 'RetryAttempts': 0} TimedMetric dataclass Internally, the package uses TimedMetric dataclass to store the metric data. This dataclass is used to store the metric data and provide a convenient interface to access the data. It can be also used to interact with the metric data by the user. response = mw . query_ec2_metrics ( ** FINE_TUNED_SETTINGS ) timed_metric = mw . timed_metric_factory ( response )[ 0 ] print ( timed_metric . __class__ ) timed_metric . values [ 1 : 10 ] <class 'cloudwatcher.metric_handlers.TimedMetric'> [1173819392.0, 1172045824.0, 1171132416.0, 1170399232.0, 1170014208.0, 1168662528.0, 1168093184.0, 2711384064.0, 2704683008.0] LogWatcher : convenient interface to AWS CloudWatch logs LogWatcher can be used to interact with AWS CloudWatch logs. Coming soon...","title":"API usage"},{"location":"API_usage/#cloudwatcher-python-api-usage","text":"The purpose of this page is to provide a quick overview of the cloudwatcher Python API. The package consists of two user-facing classes: MetricWatcher : This class is used to interact with AWS CloudWatch metrics. LogWatcher : This class is used to interact with AWS CloudWatch logs. Both of these classes inherit from the CloudWatcher class.","title":"cloudwatcher Python API usage"},{"location":"API_usage/#metricwatcher-convenient-interface-to-aws-cloudwatch-metrics","text":"MetricWatcher can be used to interact with AWS CloudWatch metrics.","title":"MetricWatcher: convenient interface to AWS CloudWatch metrics"},{"location":"API_usage/#metricwatcher-initialization","text":"As described in the Login credentials section, the AWS credentials can be sourced from environment variables: AWS_ACCESS_KEY_ID , AWS_SECRET_ACCESS_KEY , AWS_SESSION_TOKEN . Alternatively, you can pass the values as arguments to the MetricWatcher constructor. from cloudwatcher.metricwatcher import MetricWatcher from cloudwatcher.preset import Dimension from dotenv import load_dotenv import os load_dotenv () instance_id = os . environ . get ( \"INSTANCE_ID\" ) mw = MetricWatcher ( namespace = \"NepheleNamespaceEC2\" , metric_name = \"mem_used\" , metric_id = \"mem_used\" , metric_unit = \"Bytes\" , dimensions_list = [ Dimension ( Name = \"InstanceId\" , Value = instance_id )], )","title":"MetricWatcher initialization"},{"location":"API_usage/#metricwatcher-presets","text":"As you can see there are multiple arguments that can be passed to the MetricWatcher constructor. In order to improve the UX when using MetricWatcher . The cloudwatcher package provides a few presets that can be used to query the data reported by CloudWatchAgent within certain systems. Additionally, custom presets can be defined by the user and used in the same way. Presets are JSON-formatted files that provide parameter bundles for MetricWatcher initialization.","title":"MetricWatcher presets"},{"location":"API_usage/#usage","text":"Listing available presets: from cloudwatcher.preset import PresetFilesInventory from rich.console import Console pfi = PresetFilesInventory () Console () . print ( pfi . presets_table ) Presets available in: /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Path \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 nephele_disk_used_percent \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502 \u2502 nephele_mem_cached \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502 \u2502 nephele_mem \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502 \u2502 nephele_disk_used_percent_nephele_data \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502 \u2502 nephele_cpu_usage_user \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_cp\u2026 \u2502 \u2502 nephele_processes_dead \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_pr\u2026 \u2502 \u2502 nephele_swap_used_percent \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502 \u2502 nephele_swap_used \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Using a preset: from cloudwatcher.preset import MetricWatcherSetup mw_setup = MetricWatcherSetup . from_json ( pfi . get_preset_path ( \"nephele_mem\" )) mw_setup . upsert_dimensions ([ f \"InstanceId: { instance_id } \" ]) mw = MetricWatcher ( ** mw_setup . to_dict ()) query_kwargs = { \"days\" : 5 , \"hours\" : 0 , \"minutes\" : 0 , \"stat\" : \"Maximum\" , \"period\" : 60 , } response = mw . query_ec2_metrics ( ** query_kwargs )","title":"Usage"},{"location":"API_usage/#querying-aws-cloudwatch-metrics","text":"In order to specify the EC2 instace query settings (period, granularity, etc.), the user would need to provide multiple parameters. To make it easier, there are a few sensible presets that can be used to select the query settings, which are passed to query_ec2_metrics method. These presets are defined to query the data reported by CloudWatchAgent within the last day, hour or minute. The presets can be used by passing the query_preset argument to the functions presented below. Alternatively, users can pass query_kwargs argument, which overrides the preset values.","title":"Querying AWS CloudWatch metrics"},{"location":"API_usage/#logging-methods","text":"There is a method that can be used to log the metric to the screen. The EC2 instance is automatically queried if the query response is not provided.","title":"Logging methods"},{"location":"API_usage/#file-saving-methods","text":"There are number of methods that can be used to save the metric data to a file. Again, the EC2 instance is automatically queried if the query response is not provided. mw . save_metric_plot ( file_path = f \"/tmp/ { instance_id } _plot.png\" , query_kwargs = query_kwargs ) mw . save_metric_csv ( file_path = f \"/tmp/ { instance_id } _metric.csv\" , query_kwargs = query_kwargs ) mw . save_metric_json ( file_path = f \"/tmp/ { instance_id } _metric.json\" , query_kwargs = query_kwargs ) mw . save_response_json ( file_path = f \"/tmp/ { instance_id } _response.json\" , query_kwargs = query_kwargs )","title":"File saving methods"},{"location":"API_usage/#manual-ec2-querying","text":"For users that require more control over the EC2 instance query settings, the query_ec2_metrics method can be used to manually query the EC2 instance. For instance it allows to fine tune the query period settings. FINE_TUNED_SETTINGS = { \"days\" : 5 , \"hours\" : 0 , \"minutes\" : 0 , \"stat\" : \"Maximum\" , \"period\" : 60 , } response = mw . query_ec2_metrics ( ** FINE_TUNED_SETTINGS ) response [ \"ResponseMetadata\" ] {'RequestId': 'bb3880e0-17e6-45d2-a007-a7b797c6d52f', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'bb3880e0-17e6-45d2-a007-a7b797c6d52f', 'content-type': 'text/xml', 'content-length': '33663', 'date': 'Tue, 08 Nov 2022 16:46:07 GMT'}, 'RetryAttempts': 0}","title":"Manual EC2 querying"},{"location":"API_usage/#timedmetric-dataclass","text":"Internally, the package uses TimedMetric dataclass to store the metric data. This dataclass is used to store the metric data and provide a convenient interface to access the data. It can be also used to interact with the metric data by the user. response = mw . query_ec2_metrics ( ** FINE_TUNED_SETTINGS ) timed_metric = mw . timed_metric_factory ( response )[ 0 ] print ( timed_metric . __class__ ) timed_metric . values [ 1 : 10 ] <class 'cloudwatcher.metric_handlers.TimedMetric'> [1173819392.0, 1172045824.0, 1171132416.0, 1170399232.0, 1170014208.0, 1168662528.0, 1168093184.0, 2711384064.0, 2704683008.0]","title":"TimedMetric dataclass"},{"location":"API_usage/#logwatcher-convenient-interface-to-aws-cloudwatch-logs","text":"LogWatcher can be used to interact with AWS CloudWatch logs. Coming soon...","title":"LogWatcher: convenient interface to AWS CloudWatch logs"},{"location":"EC2_instance_setup/","text":"EC2 instance setup Using ECS ContainerInsights? This section may not be required for your setup . For instance, if you plan to monitor ECS containers that report the metrics with ECS ContainerInsights . In order to use the tool a CloudWatchAgent process must be running on the EC2 instance to be monitored. Please refer to this page to learn how to install and start the CloudWatchAgent on an EC2 instance. Configuration CloudWatchAgent is a powerful tool and can be configured to report variety of metrics. Here is an example of the configuration file: cloudwatch_agent_cfg.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"agent\" : { \"metrics_collection_interval\" : 10 }, \"metrics\" : { \"namespace\" : \"ExampleNamespace\" , \"metrics_collected\" : { \"mem\" : { \"measurement\" : [ \"mem_used\" , \"mem_cached\" , \"mem_total\" ], \"metrics_collection_interval\" : 1 } }, \"append_dimensions\" : { \"InstanceId\" : \"${aws:InstanceId}\" } } } The above configuration file is used to colect 3 memory metrics every second: mem_used mem_cached mem_total EC2 userdata The tool can be configured to be launched automatically by the EC2 instance userdata. Here are the steps to configure the tool to be launched automatically: Download CloudWatchAgent appropriate for your EC2 instance type; learn more here . Install CloudWatchAgent on the EC2 instance. Create/copy a CloudWatchAgent configuration file. Start the CloudWatchAgent service pointing to the created configuration file. For a Debian EC2 instance, the steps can be achieved by executing the following commands: ec2_userdata.sh 1 2 3 4 5 6 7 8 #!/bin/bash CLOUDWATCH_CFG_SRC = <path-in-repo>/config.json CLOUDWATCH_CFG_FILE = /opt/aws/amazon-cloudwatch-agent/bin/config.json wget https://s3.amazonaws.com/amazoncloudwatch-agent/debian/amd64/latest/amazon-cloudwatch-agent.deb dpkg -i -E ./amazon-cloudwatch-agent.deb cp $CLOUDWATCH_CFG_SRC $CLOUDWATCH_CFG_FILE /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s -c file: $CLOUDWATCH_CFG_FILE","title":"EC2 intance setup"},{"location":"EC2_instance_setup/#ec2-instance-setup","text":"Using ECS ContainerInsights? This section may not be required for your setup . For instance, if you plan to monitor ECS containers that report the metrics with ECS ContainerInsights . In order to use the tool a CloudWatchAgent process must be running on the EC2 instance to be monitored. Please refer to this page to learn how to install and start the CloudWatchAgent on an EC2 instance.","title":"EC2 instance setup"},{"location":"EC2_instance_setup/#configuration","text":"CloudWatchAgent is a powerful tool and can be configured to report variety of metrics. Here is an example of the configuration file: cloudwatch_agent_cfg.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"agent\" : { \"metrics_collection_interval\" : 10 }, \"metrics\" : { \"namespace\" : \"ExampleNamespace\" , \"metrics_collected\" : { \"mem\" : { \"measurement\" : [ \"mem_used\" , \"mem_cached\" , \"mem_total\" ], \"metrics_collection_interval\" : 1 } }, \"append_dimensions\" : { \"InstanceId\" : \"${aws:InstanceId}\" } } } The above configuration file is used to colect 3 memory metrics every second: mem_used mem_cached mem_total","title":"Configuration"},{"location":"EC2_instance_setup/#ec2-userdata","text":"The tool can be configured to be launched automatically by the EC2 instance userdata. Here are the steps to configure the tool to be launched automatically: Download CloudWatchAgent appropriate for your EC2 instance type; learn more here . Install CloudWatchAgent on the EC2 instance. Create/copy a CloudWatchAgent configuration file. Start the CloudWatchAgent service pointing to the created configuration file. For a Debian EC2 instance, the steps can be achieved by executing the following commands: ec2_userdata.sh 1 2 3 4 5 6 7 8 #!/bin/bash CLOUDWATCH_CFG_SRC = <path-in-repo>/config.json CLOUDWATCH_CFG_FILE = /opt/aws/amazon-cloudwatch-agent/bin/config.json wget https://s3.amazonaws.com/amazoncloudwatch-agent/debian/amd64/latest/amazon-cloudwatch-agent.deb dpkg -i -E ./amazon-cloudwatch-agent.deb cp $CLOUDWATCH_CFG_SRC $CLOUDWATCH_CFG_FILE /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s -c file: $CLOUDWATCH_CFG_FILE","title":"EC2 userdata"},{"location":"changelog/","text":"Changelog This project adheres to Semantic Versioning and Keep a Changelog format. [0.1.0] - 2022-11-08 Added presets functionality to improve UX Changed merged --dimension-name and --dimension-value into --dimensions option Removed defaults for --id , -unit , --stat etc. Presets should be used instead query_kwargs argument [0.0.6] - 2022-05-03 Added A possibility to query dimensions other than InstanceId via --dimension-name option. Removed -iid/--instance-id option. Use a combination of --dimension-name and --dimension-value from now. [0.0.4] - 2022-04-28 Added A possibility to specify EC2 query presets for CloudWatch metrics -- query_presets argument A possibility to specify EC2 query key word arguments -- query_kwargs argument [0.0.3] - 2022-04-25 Added Added support for log saving to file: cloudwatcher log --save [0.0.2] - 2022-04-25 Added Initial release","title":"Release notes"},{"location":"changelog/#changelog","text":"This project adheres to Semantic Versioning and Keep a Changelog format.","title":"Changelog"},{"location":"changelog/#010-2022-11-08","text":"","title":"[0.1.0] - 2022-11-08"},{"location":"changelog/#added","text":"presets functionality to improve UX","title":"Added"},{"location":"changelog/#changed","text":"merged --dimension-name and --dimension-value into --dimensions option","title":"Changed"},{"location":"changelog/#removed","text":"defaults for --id , -unit , --stat etc. Presets should be used instead query_kwargs argument","title":"Removed"},{"location":"changelog/#006-2022-05-03","text":"","title":"[0.0.6] - 2022-05-03"},{"location":"changelog/#added_1","text":"A possibility to query dimensions other than InstanceId via --dimension-name option.","title":"Added"},{"location":"changelog/#removed_1","text":"-iid/--instance-id option. Use a combination of --dimension-name and --dimension-value from now.","title":"Removed"},{"location":"changelog/#004-2022-04-28","text":"","title":"[0.0.4] - 2022-04-28"},{"location":"changelog/#added_2","text":"A possibility to specify EC2 query presets for CloudWatch metrics -- query_presets argument A possibility to specify EC2 query key word arguments -- query_kwargs argument","title":"Added"},{"location":"changelog/#003-2022-04-25","text":"","title":"[0.0.3] - 2022-04-25"},{"location":"changelog/#added_3","text":"Added support for log saving to file: cloudwatcher log --save","title":"Added"},{"location":"changelog/#002-2022-04-25","text":"","title":"[0.0.2] - 2022-04-25"},{"location":"changelog/#added_4","text":"Initial release","title":"Added"},{"location":"docs_development/","text":"Documentation development The documentation is built from the makrdown files in the /docs directory with static site generator MkDocs . With make Makefile The following commands are encoded in a Makefie in this repository: makefile . Serve To serve the documentation locally, you can the serve_docs target: make serve_docs The documentation is served on http://localhost:8000/ . Build To build the documentation, you can the build_docs target: make build_docs The documentation is built in the /site directory. Deploy To deploy the documentation to GitHub Pages, you can the deploy_docs target: make deploy_docs The documentation is deployed to GitHub Pages. By hand In order to serve the documentation by hand follow the steps below. Note The commands need to be run from the root of the repository, unless stated otherwise. Install the documentation-related dependancies and the Python package itself with Poetry poetry install Document the API of the package lucidoc cloudwatcher --parse rst --outfile docs/API_documentation.md Run the following command in the project root mkdocs serve Deploying the documentation In order to deploy the documentation run the following command: mkdocs gh-deploy","title":"Docs development"},{"location":"docs_development/#documentation-development","text":"The documentation is built from the makrdown files in the /docs directory with static site generator MkDocs .","title":"Documentation development"},{"location":"docs_development/#with-make","text":"Makefile The following commands are encoded in a Makefie in this repository: makefile .","title":"With make"},{"location":"docs_development/#serve","text":"To serve the documentation locally, you can the serve_docs target: make serve_docs The documentation is served on http://localhost:8000/ .","title":"Serve"},{"location":"docs_development/#build","text":"To build the documentation, you can the build_docs target: make build_docs The documentation is built in the /site directory.","title":"Build"},{"location":"docs_development/#deploy","text":"To deploy the documentation to GitHub Pages, you can the deploy_docs target: make deploy_docs The documentation is deployed to GitHub Pages.","title":"Deploy"},{"location":"docs_development/#by-hand","text":"In order to serve the documentation by hand follow the steps below. Note The commands need to be run from the root of the repository, unless stated otherwise. Install the documentation-related dependancies and the Python package itself with Poetry poetry install Document the API of the package lucidoc cloudwatcher --parse rst --outfile docs/API_documentation.md Run the following command in the project root mkdocs serve","title":"By hand"},{"location":"docs_development/#deploying-the-documentation","text":"In order to deploy the documentation run the following command: mkdocs gh-deploy","title":"Deploying the documentation"},{"location":"features/","text":"Features The tool can generate multiple outputs, depending on the options specified. Generally, they can be classified as: console output and output files . Console output Always generated. Table A table printed to the console, which can be used for visual inspection of the metrics collected. \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Time (UTC) \u2503 Value \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 19:17:30 \u2502 469.113 MB \u2502 \u2502 19:17:00 \u2502 1.721 GB \u2502 \u2502 19:16:30 \u2502 6.230 GB \u2502 \u2502 19:16:00 \u2502 7.428 GB \u2502 \u2502 19:15:30 \u2502 2.417 GB \u2502 \u2502 19:15:00 \u2502 2.752 GB \u2502 \u2502 19:14:30 \u2502 2.836 GB \u2502 \u2502 19:14:00 \u2502 1.348 GB \u2502 \u2502 19:13:30 \u2502 772.855 MB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Summary message A summary message is printed to the console: Max 'memory_usage' is 6.23 GB over 1:03:00 timespan Uptime A summary message with the uptime of the instance in seconds. It's either calculated precisely if the instance is running, or estimated based on the reported metrics over at least 15 days. If a longer period of time is desired, please use the --days option. Instance uptime is 72886 seconds Output files Generated when --save option is used. JSON with reponse A JSON file with the response from the AWS API, useful for debugging. {dimension_name}_{dimension_value}_{metric}_response.json { \"MetricDataResults\" : [ { \"Id\" : \"memory_usage\" , \"Label\" : \"mem_used\" , \"Values\" : [ 492003328.0 , 492204032.0 , 492040192.0 , 450666496.0 , 429965312.0 ], \"Timestamps\" : [ \"2021-11-12 19:19:00+00:00\" , \"2021-11-12 19:18:30+00:00\" , \"2021-11-12 19:18:00+00:00\" , \"2021-11-12 19:12:00+00:00\" , \"2021-11-12 19:11:30+00:00\" ], \"StatusCode\" : \"Complete\" } ], \"Messages\" : [], \"ResponseMetadata\" : { \"RequestId\" : \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\" , \"HTTPStatusCode\" : 200 , \"HTTPHeaders\" : { \"x-amzn-requestid\" : \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\" , \"content-type\" : \"text/xml\" , \"content-length\" : \"1954\" , \"date\" : \"Fri, 12 Nov 2021 22:05:42 GMT\" }, \"RetryAttempts\" : 0 } } JSON with metric data A JSON file with the raw data, which can be used for further analysis. {dimension_name}_{dimension_value}_{metric}.json { \"Label\" : \"mem_used\" , \"Values\" : [ 492003328.0 , 492204032.0 , 492040192.0 , 450666496.0 , 429965312.0 ], \"Timestamps\" : [ \"2021-11-12 19:19:00+00:00\" , \"2021-11-12 19:18:30+00:00\" , \"2021-11-12 19:18:00+00:00\" , \"2021-11-12 19:12:00+00:00\" , \"2021-11-12 19:11:30+00:00\" ] } CSV with metric data A CSV file with the raw data, which can be used for further analysis. {dimension_name}_{dimension_value}_{metric}.csv time,value 2021-11-12 19:19:00+00:00,492003328.0 2021-11-12 19:18:30+00:00,492204032.0 2021-11-12 19:18:00+00:00,492040192.0 2021-11-12 19:12:00+00:00,450666496.0 2021-11-12 19:11:30+00:00,429965312.0 Plot with metric data Generated when --plot option used. {dimension_name}_{dimension_value}_{metric}.png","title":"Features"},{"location":"features/#features","text":"The tool can generate multiple outputs, depending on the options specified. Generally, they can be classified as: console output and output files .","title":"Features"},{"location":"features/#console-output","text":"Always generated.","title":"Console output"},{"location":"features/#table","text":"A table printed to the console, which can be used for visual inspection of the metrics collected. \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Time (UTC) \u2503 Value \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 19:17:30 \u2502 469.113 MB \u2502 \u2502 19:17:00 \u2502 1.721 GB \u2502 \u2502 19:16:30 \u2502 6.230 GB \u2502 \u2502 19:16:00 \u2502 7.428 GB \u2502 \u2502 19:15:30 \u2502 2.417 GB \u2502 \u2502 19:15:00 \u2502 2.752 GB \u2502 \u2502 19:14:30 \u2502 2.836 GB \u2502 \u2502 19:14:00 \u2502 1.348 GB \u2502 \u2502 19:13:30 \u2502 772.855 MB \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Table"},{"location":"features/#summary-message","text":"A summary message is printed to the console: Max 'memory_usage' is 6.23 GB over 1:03:00 timespan","title":"Summary message"},{"location":"features/#uptime","text":"A summary message with the uptime of the instance in seconds. It's either calculated precisely if the instance is running, or estimated based on the reported metrics over at least 15 days. If a longer period of time is desired, please use the --days option. Instance uptime is 72886 seconds","title":"Uptime"},{"location":"features/#output-files","text":"Generated when --save option is used.","title":"Output files"},{"location":"features/#json-with-reponse","text":"A JSON file with the response from the AWS API, useful for debugging. {dimension_name}_{dimension_value}_{metric}_response.json { \"MetricDataResults\" : [ { \"Id\" : \"memory_usage\" , \"Label\" : \"mem_used\" , \"Values\" : [ 492003328.0 , 492204032.0 , 492040192.0 , 450666496.0 , 429965312.0 ], \"Timestamps\" : [ \"2021-11-12 19:19:00+00:00\" , \"2021-11-12 19:18:30+00:00\" , \"2021-11-12 19:18:00+00:00\" , \"2021-11-12 19:12:00+00:00\" , \"2021-11-12 19:11:30+00:00\" ], \"StatusCode\" : \"Complete\" } ], \"Messages\" : [], \"ResponseMetadata\" : { \"RequestId\" : \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\" , \"HTTPStatusCode\" : 200 , \"HTTPHeaders\" : { \"x-amzn-requestid\" : \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\" , \"content-type\" : \"text/xml\" , \"content-length\" : \"1954\" , \"date\" : \"Fri, 12 Nov 2021 22:05:42 GMT\" }, \"RetryAttempts\" : 0 } }","title":"JSON with reponse"},{"location":"features/#json-with-metric-data","text":"A JSON file with the raw data, which can be used for further analysis. {dimension_name}_{dimension_value}_{metric}.json { \"Label\" : \"mem_used\" , \"Values\" : [ 492003328.0 , 492204032.0 , 492040192.0 , 450666496.0 , 429965312.0 ], \"Timestamps\" : [ \"2021-11-12 19:19:00+00:00\" , \"2021-11-12 19:18:30+00:00\" , \"2021-11-12 19:18:00+00:00\" , \"2021-11-12 19:12:00+00:00\" , \"2021-11-12 19:11:30+00:00\" ] }","title":"JSON with metric data"},{"location":"features/#csv-with-metric-data","text":"A CSV file with the raw data, which can be used for further analysis. {dimension_name}_{dimension_value}_{metric}.csv time,value 2021-11-12 19:19:00+00:00,492003328.0 2021-11-12 19:18:30+00:00,492204032.0 2021-11-12 19:18:00+00:00,492040192.0 2021-11-12 19:12:00+00:00,450666496.0 2021-11-12 19:11:30+00:00,429965312.0","title":"CSV with metric data"},{"location":"features/#plot-with-metric-data","text":"Generated when --plot option used. {dimension_name}_{dimension_value}_{metric}.png","title":"Plot with metric data"},{"location":"installation/","text":"Installation The package is distributed and available on PyPI: cloudwatcher . Therefore you can install it using pip: pip install cloudwatcher","title":"Installation"},{"location":"installation/#installation","text":"The package is distributed and available on PyPI: cloudwatcher . Therefore you can install it using pip: pip install cloudwatcher","title":"Installation"},{"location":"login_credentials/","text":"Login credentials The login credentials that determine the AWS account to be used are resolved by boto3 , the official Python SDK for AWS, during the boto3.Session.client initialization. Resolution order In general, the credentials are resolved in the following order: The credentials are read from the environment variables: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY export AWS_ACCESS_KEY_ID=<access_key_id> export AWS_SECRET_ACCESS_KEY=<secret_access_key> The credentials are read from [default] section of the ~/.aws/credentials file [default] aws_access_key_id = <access_key_id> aws_secret_access_key = <secret_access_key>","title":"AWS credentials"},{"location":"login_credentials/#login-credentials","text":"The login credentials that determine the AWS account to be used are resolved by boto3 , the official Python SDK for AWS, during the boto3.Session.client initialization.","title":"Login credentials"},{"location":"login_credentials/#resolution-order","text":"In general, the credentials are resolved in the following order: The credentials are read from the environment variables: AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY export AWS_ACCESS_KEY_ID=<access_key_id> export AWS_SECRET_ACCESS_KEY=<secret_access_key> The credentials are read from [default] section of the ~/.aws/credentials file [default] aws_access_key_id = <access_key_id> aws_secret_access_key = <secret_access_key>","title":"Resolution order"},{"location":"presets/","text":"Presets In order to improve the UX when using cloudwatcher metric comamnd. The cloudwatcher package provides a few presets that can be used to query the data reported by CloudWatchAgent within certain systems. Additionally, custom presets can be defined by the user and used in the same way. Presets are JSON-formatted files that provide parameter bundles for MetricWatcher initialization. Usage The presets are used if --preset-name or --preset-path option is provided. The --preset-name option can be used to select one of the built-in presets. The --preset-path option can be used to select a custom preset. Importantly, the settings defined in the preset can be extended or overridden by the user by providing additional arguments to the cloudwatcher metric command, e.g. --dimensions key:value --metric-id test . Custom preset command example The custom preset can be defined in a JSON file, for example: custom_preset.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"namespace\" : \"MetricNamespace\" , \"dimensions_list\" : [ { \"Name\" : \"InstanceId\" , \"Value\" : \"i-0c4d9523c99fbc1da\" }, { \"Name\" : \"cpu\" , \"Value\" : \"cpu-total\" } ], \"metric_name\" : \"cpu_usage_user\" , \"metric_id\" : \"my_metric_id\" , \"metric_unit\" : \"Percent\" } The above preset can be used by passing the --preset-path option: cloudwatcher metric --preset-path custom_preset.json Built-in preset command example The built-in presets can be used by passing the --preset-name option: cloudwatcher metric --preset-name nepehele_mem","title":"Presets"},{"location":"presets/#presets","text":"In order to improve the UX when using cloudwatcher metric comamnd. The cloudwatcher package provides a few presets that can be used to query the data reported by CloudWatchAgent within certain systems. Additionally, custom presets can be defined by the user and used in the same way. Presets are JSON-formatted files that provide parameter bundles for MetricWatcher initialization.","title":"Presets"},{"location":"presets/#usage","text":"The presets are used if --preset-name or --preset-path option is provided. The --preset-name option can be used to select one of the built-in presets. The --preset-path option can be used to select a custom preset. Importantly, the settings defined in the preset can be extended or overridden by the user by providing additional arguments to the cloudwatcher metric command, e.g. --dimensions key:value --metric-id test .","title":"Usage"},{"location":"presets/#custom-preset-command-example","text":"The custom preset can be defined in a JSON file, for example: custom_preset.json 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"namespace\" : \"MetricNamespace\" , \"dimensions_list\" : [ { \"Name\" : \"InstanceId\" , \"Value\" : \"i-0c4d9523c99fbc1da\" }, { \"Name\" : \"cpu\" , \"Value\" : \"cpu-total\" } ], \"metric_name\" : \"cpu_usage_user\" , \"metric_id\" : \"my_metric_id\" , \"metric_unit\" : \"Percent\" } The above preset can be used by passing the --preset-path option: cloudwatcher metric --preset-path custom_preset.json","title":"Custom preset command example"},{"location":"presets/#built-in-preset-command-example","text":"The built-in presets can be used by passing the --preset-name option: cloudwatcher metric --preset-name nepehele_mem","title":"Built-in preset command example"},{"location":"usage/","text":"There are two modes of operation on the CLI: cloudwatcher metric cloudwatcher log cloudwatcher --help Documentation available at: https://niaid.github.io/cloudwatcher usage: cloudwatcher [-h] {metric,log} ... CloudWatch logs and metrics explorer. positional arguments: {metric,log} metric Interact with AWS CloudWatch metrics. log Interact with AWS CloudWatch logs. optional arguments: -h, --help show this help message and exit CloudWatch metrics monitoring The tool is highly configurable and can be used in a variety of ways. Naturally, the metrics available to be monitored depend on the configuration of the CloudWatchAgent process. By default the tool will report the mem_used metric starting 24 hours ago until present with granularity/period of 1 minute, expressed in Bytes. Please refer to the usage below for more options: clouwatcher metric --help Documentation available at: https://niaid.github.io/cloudwatcher usage: cloudwatcher metric [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T] [--save] [-d DIR] [-q Q] [-i ID] [-m N] [-dn N] -dv V [--uptime] [--days D] [-hr H] [-mi M] [-u U] [-s S] [-p P] [--plot] --namespace N Interact with AWS CloudWatch metrics. optional arguments: -h, --help show this help message and exit --version Print version and exit --debug Whether debug mode should be launched (default: False) --save Whether to save the results to files in the selected directory (default: False) -d DIR, --dir DIR Directory to store the results in. Used with `--save` (default: ./) -q Q, --query-json Q Path to a query JSON file. This is not implemented yet. -i ID, --id ID The unique identifier to assign to the metric data. Must be of the form '^[a-z][a-zA-Z0-9_]*$'. -m N, --metric N Name of the metric collected by CloudWatchAgent (default: mem_used) -dn N, --dimension-name N The name of the dimension to query. (default: InstanceId) -dv V, --dimension-value V The value of the dimension to filter on. --uptime Display the uptime of the instance in seconds. It's either calculated precisely if the instance is still running, or estimated based on the reported metrics. -u U, --unit U If you omit Unit then all data that was collected with any unit is returned. If you specify a unit, it acts as a filter and returns only data that was collected with that unit specified. Use 'Bytes' for memory (default: None) -s S, --stat S The statistic to apply over the time intervals, e.g. 'Maximum' (default: Maximum) -p P, --period P The granularity, in seconds, of the returned data points. Choices: 1, 5, 10, 30, 60, or any multiple of 60 (default: 60). It affects the data availability. See the docs 'Usage' section for more details. --plot Whether to plot the metric data (default: False) --namespace N Namespace to monitor the metrics within. This value must match the 'Namespace' value in the CloudWatchAgent config. AWS CREDENTIALS: Can be ommited if set in environment variables --aws-region R Region to monitor the metrics within. (default: us-east-1) --aws-access-key-id K AWS Access Key ID to use for authentication --aws-secret-access-key S AWS Secret Access Key to use for authentication --aws-session-token T AWS Session Token to use for authentication METRIC COLLECTION TIME: The time range to collect metrics from. Uptime will be estimated in the timespan starting at least 15 ago. --days D How many days to subtract from the current date to determine the metric collection start time (default: 1). -hr H, --hours H How many hours to subtract from the current time to determine the metric collection start time (default: 0). -mi M, --minutes M How many minutes to subtract from the current time to determine the metric collection start time (default: 0). Command example This minimal command will query dimesion InstanceId for mem_used in Bytes with period 60s over last 2 days. cloudwatcher metric --dimensions InstanceId:i-0e0165b35c8d648c8 --namespace NepheleNamespaceEC2 --metric mem_used --id mem_used --days 2 --stat Maximum --unit Bytes Notes on metrics availabilty Amazon CloudWatch retains metric data as follows: Data points with a period of less than 60 seconds are available for 3 hours. Data points with a period of 60 seconds (1-minute) are available for 15 days. Data points with a period of 300 seconds (5-minute) are available for 63 days. Data points with a period of 3600 seconds (1 hour) are available for 455 days (15 months). Select your period of interest accordingly. This is crucial as for example if the EC2 instance has stopped over 3 hours ago, selecting a < 60 second period will return an empty reponse. Using presets As you can see, the command required to retrieve the metrics is quite long. To make it easier to use, you can create a preset file and use it to query the metrics. Alternatively, you can use one of the built-in presets. List presets with: cloudwatcher metric --preset-list Query metrics with preset: cloudwatcher metric --preset <preset_name> CloudWatch logs monitoring clouwatcher log --help Documentation available at: https://niaid.github.io/cloudwatcher usage: cloudwatcher log [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T] [--save] [-d DIR] -g G -s S Interact with AWS CloudWatch logs. optional arguments: -h, --help show this help message and exit --version Print version and exit --debug Whether debug mode should be launched (default: False) --save Whether to save the results to files in the selected directory (default: False) -d DIR, --dir DIR Directory to store the results in. Used with `--save` (default: ./) -g G, --log-group-name G The log group name to monitor -s S, --log-stream-name S The log stream name to monitor AWS CREDENTIALS: Can be ommited if set in environment variables --aws-region R Region to monitor the metrics within. (default: us-east-1) --aws-access-key-id K AWS Access Key ID to use for authentication --aws-secret-access-key S AWS Secret Access Key to use for authentication --aws-session-token T AWS Session Token to use for authentication","title":"Usage"},{"location":"usage/#cloudwatch-metrics-monitoring","text":"The tool is highly configurable and can be used in a variety of ways. Naturally, the metrics available to be monitored depend on the configuration of the CloudWatchAgent process. By default the tool will report the mem_used metric starting 24 hours ago until present with granularity/period of 1 minute, expressed in Bytes. Please refer to the usage below for more options: clouwatcher metric --help Documentation available at: https://niaid.github.io/cloudwatcher usage: cloudwatcher metric [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T] [--save] [-d DIR] [-q Q] [-i ID] [-m N] [-dn N] -dv V [--uptime] [--days D] [-hr H] [-mi M] [-u U] [-s S] [-p P] [--plot] --namespace N Interact with AWS CloudWatch metrics. optional arguments: -h, --help show this help message and exit --version Print version and exit --debug Whether debug mode should be launched (default: False) --save Whether to save the results to files in the selected directory (default: False) -d DIR, --dir DIR Directory to store the results in. Used with `--save` (default: ./) -q Q, --query-json Q Path to a query JSON file. This is not implemented yet. -i ID, --id ID The unique identifier to assign to the metric data. Must be of the form '^[a-z][a-zA-Z0-9_]*$'. -m N, --metric N Name of the metric collected by CloudWatchAgent (default: mem_used) -dn N, --dimension-name N The name of the dimension to query. (default: InstanceId) -dv V, --dimension-value V The value of the dimension to filter on. --uptime Display the uptime of the instance in seconds. It's either calculated precisely if the instance is still running, or estimated based on the reported metrics. -u U, --unit U If you omit Unit then all data that was collected with any unit is returned. If you specify a unit, it acts as a filter and returns only data that was collected with that unit specified. Use 'Bytes' for memory (default: None) -s S, --stat S The statistic to apply over the time intervals, e.g. 'Maximum' (default: Maximum) -p P, --period P The granularity, in seconds, of the returned data points. Choices: 1, 5, 10, 30, 60, or any multiple of 60 (default: 60). It affects the data availability. See the docs 'Usage' section for more details. --plot Whether to plot the metric data (default: False) --namespace N Namespace to monitor the metrics within. This value must match the 'Namespace' value in the CloudWatchAgent config. AWS CREDENTIALS: Can be ommited if set in environment variables --aws-region R Region to monitor the metrics within. (default: us-east-1) --aws-access-key-id K AWS Access Key ID to use for authentication --aws-secret-access-key S AWS Secret Access Key to use for authentication --aws-session-token T AWS Session Token to use for authentication METRIC COLLECTION TIME: The time range to collect metrics from. Uptime will be estimated in the timespan starting at least 15 ago. --days D How many days to subtract from the current date to determine the metric collection start time (default: 1). -hr H, --hours H How many hours to subtract from the current time to determine the metric collection start time (default: 0). -mi M, --minutes M How many minutes to subtract from the current time to determine the metric collection start time (default: 0).","title":"CloudWatch metrics monitoring"},{"location":"usage/#command-example","text":"This minimal command will query dimesion InstanceId for mem_used in Bytes with period 60s over last 2 days. cloudwatcher metric --dimensions InstanceId:i-0e0165b35c8d648c8 --namespace NepheleNamespaceEC2 --metric mem_used --id mem_used --days 2 --stat Maximum --unit Bytes","title":"Command example"},{"location":"usage/#notes-on-metrics-availabilty","text":"Amazon CloudWatch retains metric data as follows: Data points with a period of less than 60 seconds are available for 3 hours. Data points with a period of 60 seconds (1-minute) are available for 15 days. Data points with a period of 300 seconds (5-minute) are available for 63 days. Data points with a period of 3600 seconds (1 hour) are available for 455 days (15 months). Select your period of interest accordingly. This is crucial as for example if the EC2 instance has stopped over 3 hours ago, selecting a < 60 second period will return an empty reponse.","title":"Notes on metrics availabilty"},{"location":"usage/#using-presets","text":"As you can see, the command required to retrieve the metrics is quite long. To make it easier to use, you can create a preset file and use it to query the metrics. Alternatively, you can use one of the built-in presets. List presets with: cloudwatcher metric --preset-list Query metrics with preset: cloudwatcher metric --preset <preset_name>","title":"Using presets"},{"location":"usage/#cloudwatch-logs-monitoring","text":"clouwatcher log --help Documentation available at: https://niaid.github.io/cloudwatcher usage: cloudwatcher log [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T] [--save] [-d DIR] -g G -s S Interact with AWS CloudWatch logs. optional arguments: -h, --help show this help message and exit --version Print version and exit --debug Whether debug mode should be launched (default: False) --save Whether to save the results to files in the selected directory (default: False) -d DIR, --dir DIR Directory to store the results in. Used with `--save` (default: ./) -g G, --log-group-name G The log group name to monitor -s S, --log-stream-name S The log stream name to monitor AWS CREDENTIALS: Can be ommited if set in environment variables --aws-region R Region to monitor the metrics within. (default: us-east-1) --aws-access-key-id K AWS Access Key ID to use for authentication --aws-secret-access-key S AWS Secret Access Key to use for authentication --aws-session-token T AWS Session Token to use for authentication","title":"CloudWatch logs monitoring"}]}