{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#cloudwatcher","title":"cloudwatcher","text":"<p><code>cloudwatcher</code> is a tool for monitoring AWS CloudWatch metrics and logs. It can be used both as a command line tool and as a Python library.</p>"},{"location":"#quick-start","title":"Quick start","text":"<p>Here are the steps to use <code>cloudwatcher</code> as a command line tool:</p> <ol> <li>Install <code>cloudwatcher</code> with <code>pip</code></li> <li>Configure target EC2 instance (optional if used with ECS ContainerInsights)</li> <li>Run <code>cloudwatcher</code> CLI or Python API</li> </ol>"},{"location":"#documentation","title":"Documentation","text":"<p>Full package documentation, which includes examples of usage and setup, can be found at: https://niaid.github.io/cloudwatcher.</p>"},{"location":"#authors","title":"Authors","text":"<ul> <li>Micha\u0142 Stolarczyk</li> </ul>"},{"location":"API_documentation/","title":"API documentation","text":""},{"location":"API_documentation/#cloudwatcher","title":"<code>CloudWatcher</code>","text":"<p>A base class for CloudWatch managers</p> Source code in <code>cloudwatcher/cloudwatcher.py</code> <pre><code>class CloudWatcher:\n\"\"\"\n    A base class for CloudWatch managers\n    \"\"\"\ndef __init__(\nself,\nservice_name: str,\naws_region_name: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n        Initialize CloudWatcher\n        Args:\n            service_name (str): The name of the service to use\n            aws_region_name (Optional[str]): The AWS region name.\n            aws_access_key_id (Optional[str]): The AWS access key ID.\n            aws_secret_access_key (Optional[str]): The AWS secret access key.\n            aws_session_token (Optional[str]): The AWS session token.\n        \"\"\"\nself.aws_region_name = aws_region_name or \"us-east-1\"\nself.service_name = service_name\nself.client: boto3.Session.client = boto3.client(\nservice_name=self.service_name,\nregion_name=self.aws_region_name,\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.cloudwatcher.CloudWatcher.__init__","title":"<code>__init__(service_name, aws_region_name=None, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None)</code>","text":"<p>Initialize CloudWatcher</p> <p>Parameters:</p> Name Type Description Default <code>service_name</code> <code>str</code> <p>The name of the service to use</p> required <code>aws_region_name</code> <code>Optional[str]</code> <p>The AWS region name.</p> <code>None</code> <code>aws_access_key_id</code> <code>Optional[str]</code> <p>The AWS access key ID.</p> <code>None</code> <code>aws_secret_access_key</code> <code>Optional[str]</code> <p>The AWS secret access key.</p> <code>None</code> <code>aws_session_token</code> <code>Optional[str]</code> <p>The AWS session token.</p> <code>None</code> Source code in <code>cloudwatcher/cloudwatcher.py</code> <pre><code>def __init__(\nself,\nservice_name: str,\naws_region_name: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Initialize CloudWatcher\n    Args:\n        service_name (str): The name of the service to use\n        aws_region_name (Optional[str]): The AWS region name.\n        aws_access_key_id (Optional[str]): The AWS access key ID.\n        aws_secret_access_key (Optional[str]): The AWS secret access key.\n        aws_session_token (Optional[str]): The AWS session token.\n    \"\"\"\nself.aws_region_name = aws_region_name or \"us-east-1\"\nself.service_name = service_name\nself.client: boto3.Session.client = boto3.client(\nservice_name=self.service_name,\nregion_name=self.aws_region_name,\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\n)\n</code></pre>"},{"location":"API_documentation/#logwatcher","title":"<code>LogWatcher</code>","text":"<p>         Bases: <code>CloudWatcher</code></p> <p>A class for AWS CloudWatch log events retrieval and parsing</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>class LogWatcher(CloudWatcher):\n\"\"\"\n    A class for AWS CloudWatch log events retrieval and parsing\n    \"\"\"\ndef __init__(\nself,\nlog_group_name: str,\nlog_stream_name: str,\nstart_token: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\naws_region_name: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n        Initialize LogWatcher\n        Args:\n            log_group_name (str): The name of the log group\n            log_stream_name (str): The name of the log stream\n            start_token (Optional[str]): The token to use for the next query\n            aws_access_key_id (Optional[str]): The AWS access key ID\n            aws_secret_access_key (Optional[str]): The AWS secret access key\n            aws_session_token (Optional[str]): The AWS session token\n            aws_region_name (Optional[str]): The AWS region name\n        \"\"\"\nsuper().__init__(\nservice_name=\"logs\",\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\naws_region_name=aws_region_name,\n)\nself.log_group_name = log_group_name\nself.log_stream_name = log_stream_name\nself.start_token = start_token\ndef __repr__(self) -&gt; str:\n\"\"\"\n        Return a string representation of the object\n        Returns:\n            str: The string representation of the object\n        \"\"\"\nreturn f\"LogWatcher('{self.log_group_name}/{self.log_stream_name}')\"\ndef check_log_exists(self) -&gt; bool:\n\"\"\"\n        Check if the log stream exists\n        Returns:\n            bool: True if the log stream exists, False otherwise\n        \"\"\"\ntry:\nresponse = self.client.describe_log_streams(\nlogGroupName=self.log_group_name,\nlogStreamNamePrefix=self.log_stream_name,\n)\nreturn True if response[\"logStreams\"] else False\nexcept Exception as e:\n_LOGGER.error(f\"Error checking if log stream exists: {e}\")\nreturn False\ndef _get_events(self, query_kwargs: Dict[str, Any]) -&gt; LogEventsList:\n\"\"\"\n        Get events from CloudWatch and update the arguments\n        for the next query with 'nextForwardToken'\n        Args:\n            query_kwargs (Dict[str, Any]): The query arguments\n        Returns:\n            List[Event]: The list of log events\n        \"\"\"\nresponse = self.client.get_log_events(**query_kwargs)\nlog_events_list = LogEventsList.from_response(response)\nquery_kwargs.update({\"nextToken\": log_events_list.next_forward_token})\nreturn log_events_list\ndef stream_cloudwatch_logs(\nself, events_limit: int = 1000, max_retry_attempts: int = 5\n) -&gt; Generator[LogEventsList, None, None]:\n\"\"\"\n        A generator that retrieves desired number of log events per iteration\n        Args:\n            events_limit (int): The number of events to retrieve per iteration.\n            max_retry_attempts (int): The number of retry attempts.\n        Returns:\n            List[Event]: The list of log events\n        \"\"\"\nquery_kwargs = dict(\nlogGroupName=self.log_group_name,\nlogStreamName=self.log_stream_name,\nlimit=events_limit,\nstartFromHead=True,\n)\nif self.start_token:\nquery_kwargs.update({\"nextToken\": self.start_token})\n_LOGGER.debug(\nf\"Retrieving log events from: {self.log_group_name}/{self.log_stream_name}\"\n)\nlog_events_list = self._get_events(query_kwargs)\nyield log_events_list\nwhile log_events_list:\nlog_events_list = self._get_events(query_kwargs)\nretry_attempts = 0\nwhile not log_events_list and max_retry_attempts &gt; retry_attempts:\nlog_events_list = self._get_events(query_kwargs)\nretry_attempts += 1\n_LOGGER.debug(\nf\"Received empty log events list. Retry attempt: {retry_attempts}\"\n)\nyield log_events_list\ndef stream_formatted_logs(\nself,\nevents_limit: int = 1000,\nmax_retry_attempts: int = 5,\nsep: str = \"&lt;br&gt;\",\n) -&gt; Generator[Tuple[str, Optional[str]], None, None]:\n\"\"\"\n        A generator that yields formatted log events\n        Args:\n            events_limit (int): The number of events to retrieve per iteration.\n            max_retry_attempts (int): The number of retry attempts.\n            sep (str): The separator to use between log events.\n        Returns:\n            Tuple[List[str], str]: The list of formatted log events and the next token\n        \"\"\"\nfor log_events_list in self.stream_cloudwatch_logs(\nevents_limit=events_limit,\nmax_retry_attempts=max_retry_attempts,\n):\nformatted_log_events = log_events_list.format_messages().events\nyield sep.join(\n[event.message for event in formatted_log_events]\n), log_events_list.next_forward_token\ndef return_formatted_logs(\nself, events_limit: int = 1000, max_retry_attempts: int = 5\n) -&gt; Tuple[str, Optional[str]]:\n\"\"\"\n        A generator that yields formatted log events\n        Args:\n            events_limit (int): The number of events to retrieve per iteration.\n            max_retry_attempts (int): The number of retry attempts.\n        Returns:\n            Tuple[str, str]: The list of formatted log events and the next token\n        \"\"\"\nformatted_events = \"\"\nfor log_events_list in self.stream_cloudwatch_logs(\nevents_limit=events_limit, max_retry_attempts=max_retry_attempts\n):\nformatted_log_events_list = log_events_list.format_messages()\nformatted_events += \"\\n\".join(\n[event.message for event in formatted_log_events_list.events]\n)\nreturn formatted_events, formatted_log_events_list.next_forward_token\ndef save_log_file(self, file_path: str) -&gt; None:\n\"\"\"\n        Save the log file to the specified path\n        Args:\n            file_path (str): The path to save the log file to.\n        \"\"\"\nlogs, _ = self.return_formatted_logs()\nwith open(file_path, \"w\") as f:\nf.write(logs)\n_LOGGER.info(\nf\"Logs '{self.log_group_name}/{self.log_stream_name}' saved to: {file_path}\"\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.__init__","title":"<code>__init__(log_group_name, log_stream_name, start_token=None, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None, aws_region_name=None)</code>","text":"<p>Initialize LogWatcher</p> <p>Parameters:</p> Name Type Description Default <code>log_group_name</code> <code>str</code> <p>The name of the log group</p> required <code>log_stream_name</code> <code>str</code> <p>The name of the log stream</p> required <code>start_token</code> <code>Optional[str]</code> <p>The token to use for the next query</p> <code>None</code> <code>aws_access_key_id</code> <code>Optional[str]</code> <p>The AWS access key ID</p> <code>None</code> <code>aws_secret_access_key</code> <code>Optional[str]</code> <p>The AWS secret access key</p> <code>None</code> <code>aws_session_token</code> <code>Optional[str]</code> <p>The AWS session token</p> <code>None</code> <code>aws_region_name</code> <code>Optional[str]</code> <p>The AWS region name</p> <code>None</code> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def __init__(\nself,\nlog_group_name: str,\nlog_stream_name: str,\nstart_token: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\naws_region_name: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Initialize LogWatcher\n    Args:\n        log_group_name (str): The name of the log group\n        log_stream_name (str): The name of the log stream\n        start_token (Optional[str]): The token to use for the next query\n        aws_access_key_id (Optional[str]): The AWS access key ID\n        aws_secret_access_key (Optional[str]): The AWS secret access key\n        aws_session_token (Optional[str]): The AWS session token\n        aws_region_name (Optional[str]): The AWS region name\n    \"\"\"\nsuper().__init__(\nservice_name=\"logs\",\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\naws_region_name=aws_region_name,\n)\nself.log_group_name = log_group_name\nself.log_stream_name = log_stream_name\nself.start_token = start_token\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the object</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string representation of the object</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"\n    Return a string representation of the object\n    Returns:\n        str: The string representation of the object\n    \"\"\"\nreturn f\"LogWatcher('{self.log_group_name}/{self.log_stream_name}')\"\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.check_log_exists","title":"<code>check_log_exists()</code>","text":"<p>Check if the log stream exists</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the log stream exists, False otherwise</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def check_log_exists(self) -&gt; bool:\n\"\"\"\n    Check if the log stream exists\n    Returns:\n        bool: True if the log stream exists, False otherwise\n    \"\"\"\ntry:\nresponse = self.client.describe_log_streams(\nlogGroupName=self.log_group_name,\nlogStreamNamePrefix=self.log_stream_name,\n)\nreturn True if response[\"logStreams\"] else False\nexcept Exception as e:\n_LOGGER.error(f\"Error checking if log stream exists: {e}\")\nreturn False\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.return_formatted_logs","title":"<code>return_formatted_logs(events_limit=1000, max_retry_attempts=5)</code>","text":"<p>A generator that yields formatted log events</p> <p>Parameters:</p> Name Type Description Default <code>events_limit</code> <code>int</code> <p>The number of events to retrieve per iteration.</p> <code>1000</code> <code>max_retry_attempts</code> <code>int</code> <p>The number of retry attempts.</p> <code>5</code> <p>Returns:</p> Type Description <code>Tuple[str, Optional[str]]</code> <p>Tuple[str, str]: The list of formatted log events and the next token</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def return_formatted_logs(\nself, events_limit: int = 1000, max_retry_attempts: int = 5\n) -&gt; Tuple[str, Optional[str]]:\n\"\"\"\n    A generator that yields formatted log events\n    Args:\n        events_limit (int): The number of events to retrieve per iteration.\n        max_retry_attempts (int): The number of retry attempts.\n    Returns:\n        Tuple[str, str]: The list of formatted log events and the next token\n    \"\"\"\nformatted_events = \"\"\nfor log_events_list in self.stream_cloudwatch_logs(\nevents_limit=events_limit, max_retry_attempts=max_retry_attempts\n):\nformatted_log_events_list = log_events_list.format_messages()\nformatted_events += \"\\n\".join(\n[event.message for event in formatted_log_events_list.events]\n)\nreturn formatted_events, formatted_log_events_list.next_forward_token\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.save_log_file","title":"<code>save_log_file(file_path)</code>","text":"<p>Save the log file to the specified path</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to save the log file to.</p> required Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def save_log_file(self, file_path: str) -&gt; None:\n\"\"\"\n    Save the log file to the specified path\n    Args:\n        file_path (str): The path to save the log file to.\n    \"\"\"\nlogs, _ = self.return_formatted_logs()\nwith open(file_path, \"w\") as f:\nf.write(logs)\n_LOGGER.info(\nf\"Logs '{self.log_group_name}/{self.log_stream_name}' saved to: {file_path}\"\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.stream_cloudwatch_logs","title":"<code>stream_cloudwatch_logs(events_limit=1000, max_retry_attempts=5)</code>","text":"<p>A generator that retrieves desired number of log events per iteration</p> <p>Parameters:</p> Name Type Description Default <code>events_limit</code> <code>int</code> <p>The number of events to retrieve per iteration.</p> <code>1000</code> <code>max_retry_attempts</code> <code>int</code> <p>The number of retry attempts.</p> <code>5</code> <p>Returns:</p> Type Description <code>Generator[LogEventsList, None, None]</code> <p>List[Event]: The list of log events</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def stream_cloudwatch_logs(\nself, events_limit: int = 1000, max_retry_attempts: int = 5\n) -&gt; Generator[LogEventsList, None, None]:\n\"\"\"\n    A generator that retrieves desired number of log events per iteration\n    Args:\n        events_limit (int): The number of events to retrieve per iteration.\n        max_retry_attempts (int): The number of retry attempts.\n    Returns:\n        List[Event]: The list of log events\n    \"\"\"\nquery_kwargs = dict(\nlogGroupName=self.log_group_name,\nlogStreamName=self.log_stream_name,\nlimit=events_limit,\nstartFromHead=True,\n)\nif self.start_token:\nquery_kwargs.update({\"nextToken\": self.start_token})\n_LOGGER.debug(\nf\"Retrieving log events from: {self.log_group_name}/{self.log_stream_name}\"\n)\nlog_events_list = self._get_events(query_kwargs)\nyield log_events_list\nwhile log_events_list:\nlog_events_list = self._get_events(query_kwargs)\nretry_attempts = 0\nwhile not log_events_list and max_retry_attempts &gt; retry_attempts:\nlog_events_list = self._get_events(query_kwargs)\nretry_attempts += 1\n_LOGGER.debug(\nf\"Received empty log events list. Retry attempt: {retry_attempts}\"\n)\nyield log_events_list\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogWatcher.stream_formatted_logs","title":"<code>stream_formatted_logs(events_limit=1000, max_retry_attempts=5, sep='&lt;br&gt;')</code>","text":"<p>A generator that yields formatted log events</p> <p>Parameters:</p> Name Type Description Default <code>events_limit</code> <code>int</code> <p>The number of events to retrieve per iteration.</p> <code>1000</code> <code>max_retry_attempts</code> <code>int</code> <p>The number of retry attempts.</p> <code>5</code> <code>sep</code> <code>str</code> <p>The separator to use between log events.</p> <code>'&lt;br&gt;'</code> <p>Returns:</p> Type Description <code>Generator[Tuple[str, Optional[str]], None, None]</code> <p>Tuple[List[str], str]: The list of formatted log events and the next token</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def stream_formatted_logs(\nself,\nevents_limit: int = 1000,\nmax_retry_attempts: int = 5,\nsep: str = \"&lt;br&gt;\",\n) -&gt; Generator[Tuple[str, Optional[str]], None, None]:\n\"\"\"\n    A generator that yields formatted log events\n    Args:\n        events_limit (int): The number of events to retrieve per iteration.\n        max_retry_attempts (int): The number of retry attempts.\n        sep (str): The separator to use between log events.\n    Returns:\n        Tuple[List[str], str]: The list of formatted log events and the next token\n    \"\"\"\nfor log_events_list in self.stream_cloudwatch_logs(\nevents_limit=events_limit,\nmax_retry_attempts=max_retry_attempts,\n):\nformatted_log_events = log_events_list.format_messages().events\nyield sep.join(\n[event.message for event in formatted_log_events]\n), log_events_list.next_forward_token\n</code></pre>"},{"location":"API_documentation/#metricwatcher","title":"<code>MetricWatcher</code>","text":"<p>         Bases: <code>CloudWatcher</code></p> <p>A class for AWS CloudWatch metric retrieval and parsing</p> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>class MetricWatcher(CloudWatcher):\n\"\"\"\n    A class for AWS CloudWatch metric retrieval and parsing\n    \"\"\"\ndef __init__(\nself,\nnamespace: str,\ndimensions_list: List[Dimension],\nmetric_name: str,\nmetric_id: str,\nmetric_unit: Optional[str] = None,\nmetric_description: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\naws_region_name: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n        Initialize MetricWatcher\n        Args:\n            namespace (str): the namespace of the metric\n            dimensions_list (List[Dimension]): the dimensions of the metric\n            metric_name (str): the name of the metric\n            metric_id (str): the ID of the metric\n            metric_unit (Optional[str]): the unit of the metric\n            aws_access_key_id (Optional[str]): the AWS access key ID\n            aws_secret_access_key (Optional[str]): the AWS secret access key\n            aws_session_token (Optional[str]): the AWS session token\n            aws_region_name (Optional[str]): the AWS region name\n        \"\"\"\nsuper().__init__(\nservice_name=\"cloudwatch\",\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\naws_region_name=aws_region_name,\n)\nself.namespace = namespace\nself.dimensions_list = dimensions_list\nself.metric_name = metric_name\nself.metric_id = metric_id\nself.metric_unit = metric_unit\nself.ec2_resource = boto3.resource(\nservice_name=\"ec2\",\nregion_name=self.aws_region_name,\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\n)\nself.metric_description = metric_description\ndef query_ec2_metrics(\nself,\ndays: int,\nhours: int,\nminutes: int,\nstat: str,\nperiod: int,\n) -&gt; Optional[Dict]:\n\"\"\"\n        Query EC2 metrics\n        Args:\n            days (int): how many days to subtract from the current date to determine\n                the metric collection start time\n            hours (int): how many hours to subtract from the current time to determine\n                the metric collection start time\n            minutes (int): how many minutes to subtract from the current time to\n                determine the metric collection start time\n            stat (str): the statistic to query\n            period (int): the period of the metric\n        Returns:\n            Dict: the response from the query, check the structure of the\n            response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501\n        \"\"\"\nif self.namespace is None:\nraise ValueError(f\"Invalid metric namespace to watch: {self.namespace}\")\n# Create CloudWatch client\nnow = datetime.datetime.now(pytz.utc)\nstart_time = now - datetime.timedelta(days=days, hours=hours, minutes=minutes)\ndef _time(x: datetime.datetime):\n\"\"\"\n            Format a datetime object for logging\n            Args:\n                x (datetime.datetime): the datetime object to format\n            \"\"\"\nreturn x.strftime(\"%Y-%m-%d %H:%M:%S\")\n_LOGGER.info(\nf\"Querying '{self.metric_name}' for dimensions {self.dimensions_list} \"\nf\"from {_time(start_time)} to {_time(now)}\"\n)\nresponse = self.client.get_metric_data(\nMetricDataQueries=[\n{\n\"Id\": self.metric_id,\n\"MetricStat\": {\n\"Metric\": {\n\"Namespace\": self.namespace,\n\"MetricName\": self.metric_name,\n\"Dimensions\": [dim.dict() for dim in self.dimensions_list],\n},\n\"Stat\": stat,\n\"Unit\": str(\nself.metric_unit\n),  # str(None) is desired, if no unit is specified\n\"Period\": period,\n},\n},\n],\nStartTime=start_time,\nEndTime=now,\n)\nresp_status = response[\"ResponseMetadata\"][\"HTTPStatusCode\"]\nif resp_status != 200:\n_LOGGER.error(f\"Invalid response status code: {resp_status}\")\nreturn None\n_LOGGER.debug(f\"Response status code: {resp_status}\")\nreturn response\ndef get_ec2_uptime(\nself,\nec2_instance_id: str,\ndays: int,\nhours: int,\nminutes: int,\nperiod: int = 60,\n) -&gt; Optional[float]:\n\"\"\"\n        Get the runtime of an EC2 instance\n        Args:\n            ec2_instance_id (str): the ID of the EC2 instance\n            days (int): how many days to subtract from the current date to determine\n                the metric collection start time\n            hours (int): how many hours to subtract from the current time to determine\n                 the metric collection start time\n            minutes (int): how many minutes to subtract from the current time to\n                determine the metric collection start time\n        Returns:\n            float: the runtime of the EC2 instance in minutes\n        \"\"\"\nif not self.is_ec2_running(ec2_instance_id):\n_LOGGER.info(\nf\"Instance '{ec2_instance_id}' is not running anymore. \"\nf\"Uptime will be estimated based on reported metrics in \"\nf\"the last {days} days\"\n)\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\n# get the latest reported metric\nmetrics_response = self.query_ec2_metrics(\ndays=days,\nhours=hours,\nminutes=minutes,\nstat=\"Maximum\",  # any stat works\nperiod=period,  # most precise period that AWS stores for instances\n# where start time is between 3 hours and 15 days ago is 60 seconds\n)\nif metrics_response is None:\nreturn None\n# extract the latest metric report time\ntimed_metrics = self.timed_metric_factory(metrics_response)\ntry:\nearliest_metric_report_time = timed_metrics[-1].timestamps[0]\nlatest_metric_report_time = timed_metrics[-1].timestamps[-1]\nreturn (\nearliest_metric_report_time - latest_metric_report_time\n).total_seconds()\nexcept IndexError:\n_LOGGER.warning(f\"No metric data found for EC2: {ec2_instance_id}\")\nreturn None\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\nif len(list(instances)) != 1:\nraise Exception(f\"Multiple EC2 instances matched by ID: {ec2_instance_id}\")\ninstance = list(instances)[0]\n_LOGGER.info(\nf\"Instance '{ec2_instance_id}' is still running. \"\nf\"Launch time: {instance.launch_time}\"\n)\nreturn (datetime.datetime.now(pytz.utc) - instance.launch_time).total_seconds()\ndef is_ec2_running(self, ec2_instance_id: str) -&gt; bool:\n\"\"\"\n        Check if EC2 instance is running\n        Args:\n            ec2_instance_id (str): the ID of the EC2 instance\n        Returns:\n            bool: True if EC2 instance is running, False otherwise.\n        \"\"\"\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\nif len(list(instances)) == 0:\nreturn False\nif len(list(instances)) &gt; 1:\nraise Exception(f\"Multiple EC2 instances matched by ID: {ec2_instance_id}\")\nfor instance in instances:\n# check the status codes and their meanings:\n# https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501\nif instance.state[\"Code\"] &lt;= 16:\nreturn True\nreturn False\n@staticmethod\ndef timed_metric_factory(response: dict) -&gt; List[TimedMetric]:\n\"\"\"\n        Create a collection of TimedMetrics from the CloudWatch client response.\n        Args:\n            response (dict): the response from the query\n        Returns:\n            List[TimedMetric]: a collection of TimedMetrics\n        \"\"\"\nreturn [\nTimedMetric(\nlabel=metric_data_result[\"Label\"],\ntimestamps=metric_data_result[\"Timestamps\"],\nvalues=metric_data_result[\"Values\"],\n)\nfor metric_data_result in response[\"MetricDataResults\"]\n]\ndef _exec_timed_metric_handler(\nself,\nhandler_class: Type,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Internal method to execute a TimedMetricHandler\n        Args:\n            handler_class (TimedMetricHandler): the TimedMetricHandler to execute\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[Dict]): the query kwargs to use for the query\n            **kwargs: additional kwargs to pass to the handler\n        \"\"\"\n_LOGGER.debug(f\"Executing '{handler_class.__name__}'\")\nif response is None:\nif query_kwargs is not None:\nresponse = self.query_ec2_metrics(**query_kwargs)\nelse:\nraise ValueError(\"Either response or query_kwargs must be provided\")\nif response is None:\nreturn None\ntimed_metrics = self.timed_metric_factory(response)\nfor timed_metric in timed_metrics:\nif len(timed_metric.values) &lt; 1:\ncontinue\nhandler = handler_class(timed_metric=timed_metric)\nhandler(**kwargs)\ndef _exec_response_handler(\nself,\nhandler_class: Type,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n**kwargs,\n) -&gt; None:\n\"\"\"\n        Internal method to execute a ResponseHandler\n        Args:\n            handler_class (ResponseHandler): the ResponseHandler to execute\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[Dict]): the query kwargs to use for the query\n            **kwargs: additional kwargs to pass to the handler\n        \"\"\"\n_LOGGER.debug(f\"Executing '{handler_class.__class__.__name__}'\")\nif response is None:\nif query_kwargs is not None:\nresponse = self.query_ec2_metrics(**query_kwargs)\nelse:\nraise ValueError(\"Either response or query_kwargs must be provided\")\nhandler = handler_class(response=response)\nif kwargs is None:\nhandler()\nelse:\nhandler(**kwargs)\ndef save_metric_json(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n        Query and save the metric data to a JSON file\n        Args:\n            file_path (str): the file path to save the metric data to\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[str]): the query preset to use for the query\n        \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricJsonSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\ndef save_metric_csv(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n        Query and save the metric data to a CSV file\n        Args:\n            file_path (str): the file path to save the metric data to\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[str]): the query preset to use for the query\n        \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricCsvSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\ndef log_metric(self, response: Optional[Dict] = None):\n\"\"\"\n        Query and log the metric data\n        Args:\n            response (Optional[Dict]): the response from the query\n        \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricLogger,\ntarget=None,  # TODO: add support for saving to file\nresponse=response,\n)\ndef save_metric_plot(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n        Query and plot the metric data\n        Args:\n            file_path (str): the file path to save the metric data to\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[str]): the query preset to use for the query\n        \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricPlotter,\ntarget=file_path,\nmetric_unit=self.metric_unit,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\ndef log_metric_summary(self, response: Optional[Dict] = None):\n\"\"\"\n        Query and summarize the metric data to a JSON file\n        Args:\n            response (Optional[Dict]): the response from the query\n        \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricSummarizer,\ntarget=None,  # TODO: add support for saving to file\nmetric_unit=self.metric_unit,\nsummarizer=(\"Max\", max),\nresponse=response,\n)\ndef save_response_json(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n        Query and save the response data to a JSON file\n        Args:\n            file_path (str): the file path to save the response data to\n            response (Optional[Dict]): the response from the query\n            query_kwargs (Optional[str]): the query preset to use for the query\n        \"\"\"\nself._exec_response_handler(\nResponseSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\ndef log_response(self, response: Optional[Dict] = None):\n\"\"\"\n        Query and log the response\n        Args:\n            response (Optional[Dict]): the response from the query\n        \"\"\"\nself._exec_response_handler(\nResponseLogger,\ntarget=None,\nresponse=response,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.__init__","title":"<code>__init__(namespace, dimensions_list, metric_name, metric_id, metric_unit=None, metric_description=None, aws_access_key_id=None, aws_secret_access_key=None, aws_session_token=None, aws_region_name=None)</code>","text":"<p>Initialize MetricWatcher</p> <p>Parameters:</p> Name Type Description Default <code>namespace</code> <code>str</code> <p>the namespace of the metric</p> required <code>dimensions_list</code> <code>List[Dimension]</code> <p>the dimensions of the metric</p> required <code>metric_name</code> <code>str</code> <p>the name of the metric</p> required <code>metric_id</code> <code>str</code> <p>the ID of the metric</p> required <code>metric_unit</code> <code>Optional[str]</code> <p>the unit of the metric</p> <code>None</code> <code>aws_access_key_id</code> <code>Optional[str]</code> <p>the AWS access key ID</p> <code>None</code> <code>aws_secret_access_key</code> <code>Optional[str]</code> <p>the AWS secret access key</p> <code>None</code> <code>aws_session_token</code> <code>Optional[str]</code> <p>the AWS session token</p> <code>None</code> <code>aws_region_name</code> <code>Optional[str]</code> <p>the AWS region name</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def __init__(\nself,\nnamespace: str,\ndimensions_list: List[Dimension],\nmetric_name: str,\nmetric_id: str,\nmetric_unit: Optional[str] = None,\nmetric_description: Optional[str] = None,\naws_access_key_id: Optional[str] = None,\naws_secret_access_key: Optional[str] = None,\naws_session_token: Optional[str] = None,\naws_region_name: Optional[str] = None,\n) -&gt; None:\n\"\"\"\n    Initialize MetricWatcher\n    Args:\n        namespace (str): the namespace of the metric\n        dimensions_list (List[Dimension]): the dimensions of the metric\n        metric_name (str): the name of the metric\n        metric_id (str): the ID of the metric\n        metric_unit (Optional[str]): the unit of the metric\n        aws_access_key_id (Optional[str]): the AWS access key ID\n        aws_secret_access_key (Optional[str]): the AWS secret access key\n        aws_session_token (Optional[str]): the AWS session token\n        aws_region_name (Optional[str]): the AWS region name\n    \"\"\"\nsuper().__init__(\nservice_name=\"cloudwatch\",\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\naws_region_name=aws_region_name,\n)\nself.namespace = namespace\nself.dimensions_list = dimensions_list\nself.metric_name = metric_name\nself.metric_id = metric_id\nself.metric_unit = metric_unit\nself.ec2_resource = boto3.resource(\nservice_name=\"ec2\",\nregion_name=self.aws_region_name,\naws_access_key_id=aws_access_key_id,\naws_secret_access_key=aws_secret_access_key,\naws_session_token=aws_session_token,\n)\nself.metric_description = metric_description\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.get_ec2_uptime","title":"<code>get_ec2_uptime(ec2_instance_id, days, hours, minutes, period=60)</code>","text":"<p>Get the runtime of an EC2 instance</p> <p>Parameters:</p> Name Type Description Default <code>ec2_instance_id</code> <code>str</code> <p>the ID of the EC2 instance</p> required <code>days</code> <code>int</code> <p>how many days to subtract from the current date to determine the metric collection start time</p> required <code>hours</code> <code>int</code> <p>how many hours to subtract from the current time to determine  the metric collection start time</p> required <code>minutes</code> <code>int</code> <p>how many minutes to subtract from the current time to determine the metric collection start time</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>Optional[float]</code> <p>the runtime of the EC2 instance in minutes</p> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def get_ec2_uptime(\nself,\nec2_instance_id: str,\ndays: int,\nhours: int,\nminutes: int,\nperiod: int = 60,\n) -&gt; Optional[float]:\n\"\"\"\n    Get the runtime of an EC2 instance\n    Args:\n        ec2_instance_id (str): the ID of the EC2 instance\n        days (int): how many days to subtract from the current date to determine\n            the metric collection start time\n        hours (int): how many hours to subtract from the current time to determine\n             the metric collection start time\n        minutes (int): how many minutes to subtract from the current time to\n            determine the metric collection start time\n    Returns:\n        float: the runtime of the EC2 instance in minutes\n    \"\"\"\nif not self.is_ec2_running(ec2_instance_id):\n_LOGGER.info(\nf\"Instance '{ec2_instance_id}' is not running anymore. \"\nf\"Uptime will be estimated based on reported metrics in \"\nf\"the last {days} days\"\n)\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\n# get the latest reported metric\nmetrics_response = self.query_ec2_metrics(\ndays=days,\nhours=hours,\nminutes=minutes,\nstat=\"Maximum\",  # any stat works\nperiod=period,  # most precise period that AWS stores for instances\n# where start time is between 3 hours and 15 days ago is 60 seconds\n)\nif metrics_response is None:\nreturn None\n# extract the latest metric report time\ntimed_metrics = self.timed_metric_factory(metrics_response)\ntry:\nearliest_metric_report_time = timed_metrics[-1].timestamps[0]\nlatest_metric_report_time = timed_metrics[-1].timestamps[-1]\nreturn (\nearliest_metric_report_time - latest_metric_report_time\n).total_seconds()\nexcept IndexError:\n_LOGGER.warning(f\"No metric data found for EC2: {ec2_instance_id}\")\nreturn None\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\nif len(list(instances)) != 1:\nraise Exception(f\"Multiple EC2 instances matched by ID: {ec2_instance_id}\")\ninstance = list(instances)[0]\n_LOGGER.info(\nf\"Instance '{ec2_instance_id}' is still running. \"\nf\"Launch time: {instance.launch_time}\"\n)\nreturn (datetime.datetime.now(pytz.utc) - instance.launch_time).total_seconds()\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.is_ec2_running","title":"<code>is_ec2_running(ec2_instance_id)</code>","text":"<p>Check if EC2 instance is running</p> <p>Parameters:</p> Name Type Description Default <code>ec2_instance_id</code> <code>str</code> <p>the ID of the EC2 instance</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if EC2 instance is running, False otherwise.</p> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def is_ec2_running(self, ec2_instance_id: str) -&gt; bool:\n\"\"\"\n    Check if EC2 instance is running\n    Args:\n        ec2_instance_id (str): the ID of the EC2 instance\n    Returns:\n        bool: True if EC2 instance is running, False otherwise.\n    \"\"\"\ninstances = self.ec2_resource.instances.filter(\nFilters=[{\"Name\": \"instance-id\", \"Values\": [ec2_instance_id]}]\n)\nif len(list(instances)) == 0:\nreturn False\nif len(list(instances)) &gt; 1:\nraise Exception(f\"Multiple EC2 instances matched by ID: {ec2_instance_id}\")\nfor instance in instances:\n# check the status codes and their meanings:\n# https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_InstanceState.html # noqa: E501\nif instance.state[\"Code\"] &lt;= 16:\nreturn True\nreturn False\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_metric","title":"<code>log_metric(response=None)</code>","text":"<p>Query and log the metric data</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def log_metric(self, response: Optional[Dict] = None):\n\"\"\"\n    Query and log the metric data\n    Args:\n        response (Optional[Dict]): the response from the query\n    \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricLogger,\ntarget=None,  # TODO: add support for saving to file\nresponse=response,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_metric_summary","title":"<code>log_metric_summary(response=None)</code>","text":"<p>Query and summarize the metric data to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def log_metric_summary(self, response: Optional[Dict] = None):\n\"\"\"\n    Query and summarize the metric data to a JSON file\n    Args:\n        response (Optional[Dict]): the response from the query\n    \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricSummarizer,\ntarget=None,  # TODO: add support for saving to file\nmetric_unit=self.metric_unit,\nsummarizer=(\"Max\", max),\nresponse=response,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.log_response","title":"<code>log_response(response=None)</code>","text":"<p>Query and log the response</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def log_response(self, response: Optional[Dict] = None):\n\"\"\"\n    Query and log the response\n    Args:\n        response (Optional[Dict]): the response from the query\n    \"\"\"\nself._exec_response_handler(\nResponseLogger,\ntarget=None,\nresponse=response,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.query_ec2_metrics","title":"<code>query_ec2_metrics(days, hours, minutes, stat, period)</code>","text":"<p>Query EC2 metrics</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <code>int</code> <p>how many days to subtract from the current date to determine the metric collection start time</p> required <code>hours</code> <code>int</code> <p>how many hours to subtract from the current time to determine the metric collection start time</p> required <code>minutes</code> <code>int</code> <p>how many minutes to subtract from the current time to determine the metric collection start time</p> required <code>stat</code> <code>str</code> <p>the statistic to query</p> required <code>period</code> <code>int</code> <p>the period of the metric</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Optional[Dict]</code> <p>the response from the query, check the structure of the</p> <code>Optional[Dict]</code> <p>response here # noqa: E501</p> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def query_ec2_metrics(\nself,\ndays: int,\nhours: int,\nminutes: int,\nstat: str,\nperiod: int,\n) -&gt; Optional[Dict]:\n\"\"\"\n    Query EC2 metrics\n    Args:\n        days (int): how many days to subtract from the current date to determine\n            the metric collection start time\n        hours (int): how many hours to subtract from the current time to determine\n            the metric collection start time\n        minutes (int): how many minutes to subtract from the current time to\n            determine the metric collection start time\n        stat (str): the statistic to query\n        period (int): the period of the metric\n    Returns:\n        Dict: the response from the query, check the structure of the\n        response [here](https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_data) # noqa: E501\n    \"\"\"\nif self.namespace is None:\nraise ValueError(f\"Invalid metric namespace to watch: {self.namespace}\")\n# Create CloudWatch client\nnow = datetime.datetime.now(pytz.utc)\nstart_time = now - datetime.timedelta(days=days, hours=hours, minutes=minutes)\ndef _time(x: datetime.datetime):\n\"\"\"\n        Format a datetime object for logging\n        Args:\n            x (datetime.datetime): the datetime object to format\n        \"\"\"\nreturn x.strftime(\"%Y-%m-%d %H:%M:%S\")\n_LOGGER.info(\nf\"Querying '{self.metric_name}' for dimensions {self.dimensions_list} \"\nf\"from {_time(start_time)} to {_time(now)}\"\n)\nresponse = self.client.get_metric_data(\nMetricDataQueries=[\n{\n\"Id\": self.metric_id,\n\"MetricStat\": {\n\"Metric\": {\n\"Namespace\": self.namespace,\n\"MetricName\": self.metric_name,\n\"Dimensions\": [dim.dict() for dim in self.dimensions_list],\n},\n\"Stat\": stat,\n\"Unit\": str(\nself.metric_unit\n),  # str(None) is desired, if no unit is specified\n\"Period\": period,\n},\n},\n],\nStartTime=start_time,\nEndTime=now,\n)\nresp_status = response[\"ResponseMetadata\"][\"HTTPStatusCode\"]\nif resp_status != 200:\n_LOGGER.error(f\"Invalid response status code: {resp_status}\")\nreturn None\n_LOGGER.debug(f\"Response status code: {resp_status}\")\nreturn response\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_csv","title":"<code>save_metric_csv(file_path, response=None, query_kwargs=None)</code>","text":"<p>Query and save the metric data to a CSV file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file path to save the metric data to</p> required <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> <code>query_kwargs</code> <code>Optional[str]</code> <p>the query preset to use for the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def save_metric_csv(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n    Query and save the metric data to a CSV file\n    Args:\n        file_path (str): the file path to save the metric data to\n        response (Optional[Dict]): the response from the query\n        query_kwargs (Optional[str]): the query preset to use for the query\n    \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricCsvSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_json","title":"<code>save_metric_json(file_path, response=None, query_kwargs=None)</code>","text":"<p>Query and save the metric data to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file path to save the metric data to</p> required <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> <code>query_kwargs</code> <code>Optional[str]</code> <p>the query preset to use for the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def save_metric_json(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n    Query and save the metric data to a JSON file\n    Args:\n        file_path (str): the file path to save the metric data to\n        response (Optional[Dict]): the response from the query\n        query_kwargs (Optional[str]): the query preset to use for the query\n    \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricJsonSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_metric_plot","title":"<code>save_metric_plot(file_path, response=None, query_kwargs=None)</code>","text":"<p>Query and plot the metric data</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file path to save the metric data to</p> required <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> <code>query_kwargs</code> <code>Optional[str]</code> <p>the query preset to use for the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def save_metric_plot(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n    Query and plot the metric data\n    Args:\n        file_path (str): the file path to save the metric data to\n        response (Optional[Dict]): the response from the query\n        query_kwargs (Optional[str]): the query preset to use for the query\n    \"\"\"\nself._exec_timed_metric_handler(\nTimedMetricPlotter,\ntarget=file_path,\nmetric_unit=self.metric_unit,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.save_response_json","title":"<code>save_response_json(file_path, response=None, query_kwargs=None)</code>","text":"<p>Query and save the response data to a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file path to save the response data to</p> required <code>response</code> <code>Optional[Dict]</code> <p>the response from the query</p> <code>None</code> <code>query_kwargs</code> <code>Optional[str]</code> <p>the query preset to use for the query</p> <code>None</code> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>def save_response_json(\nself,\nfile_path: str,\nresponse: Optional[Dict] = None,\nquery_kwargs: Optional[Dict] = None,\n):\n\"\"\"\n    Query and save the response data to a JSON file\n    Args:\n        file_path (str): the file path to save the response data to\n        response (Optional[Dict]): the response from the query\n        query_kwargs (Optional[str]): the query preset to use for the query\n    \"\"\"\nself._exec_response_handler(\nResponseSaver,\ntarget=file_path,\nresponse=response,\nquery_kwargs=query_kwargs,\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metricwatcher.MetricWatcher.timed_metric_factory","title":"<code>timed_metric_factory(response)</code>  <code>staticmethod</code>","text":"<p>Create a collection of TimedMetrics from the CloudWatch client response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>the response from the query</p> required <p>Returns:</p> Type Description <code>List[TimedMetric]</code> <p>List[TimedMetric]: a collection of TimedMetrics</p> Source code in <code>cloudwatcher/metricwatcher.py</code> <pre><code>@staticmethod\ndef timed_metric_factory(response: dict) -&gt; List[TimedMetric]:\n\"\"\"\n    Create a collection of TimedMetrics from the CloudWatch client response.\n    Args:\n        response (dict): the response from the query\n    Returns:\n        List[TimedMetric]: a collection of TimedMetrics\n    \"\"\"\nreturn [\nTimedMetric(\nlabel=metric_data_result[\"Label\"],\ntimestamps=metric_data_result[\"Timestamps\"],\nvalues=metric_data_result[\"Values\"],\n)\nfor metric_data_result in response[\"MetricDataResults\"]\n]\n</code></pre>"},{"location":"API_documentation/#metricwatchersetup","title":"<code>MetricWatcherSetup</code>","text":"<p>A class for the setup of the MetricWatcher</p> Source code in <code>cloudwatcher/preset.py</code> <pre><code>@dataclass\nclass MetricWatcherSetup:\n\"\"\"\n    A class for the setup of the MetricWatcher\n    \"\"\"\nnamespace: str\ndimensions_list: List[Dimension]\nmetric_name: str\nmetric_id: str\nmetric_unit: str\naws_access_key_id: Optional[str] = None\naws_secret_access_key: Optional[str] = None\naws_session_token: Optional[str] = None\naws_region_name: Optional[str] = None\nmetric_description: Optional[str] = None\ndef __post_init__(self):\nself.aws_access_key_id = self.aws_access_key_id or os.environ.get(\n\"AWS_ACCESS_KEY_ID\"\n)\nself.aws_secret_access_key = self.aws_secret_access_key or os.environ.get(\n\"AWS_SECRET_ACCESS_KEY\"\n)\nself.aws_session_token = self.aws_session_token or os.environ.get(\n\"AWS_SESSION_TOKEN\"\n)\nself.aws_region_name = self.aws_region_name or os.environ.get(\n\"AWS_DEFAULT_REGION\"\n)\nself.dimensions_list = [\nDimension(**dimension) for dimension in self.dimensions_list\n]\n@classmethod\ndef from_dict(cls, data: dict) -&gt; \"MetricWatcherSetup\":\n\"\"\"\n        Create a MetricWatcherSetup object from a dictionary\n        Args:\n            data (dict): The dictionary to use\n        \"\"\"\nreturn cls(**data)\n@classmethod\ndef from_json(cls, file_path: Path) -&gt; \"MetricWatcherSetup\":\n\"\"\"\n        Create a MetricWatcherSetup object from a JSON file\n        Args:\n            file_path (str): The path to the JSON file\n        \"\"\"\nwith open(file_path) as f:\ndata = json.load(f)\nreturn cls.from_dict(data)\ndef to_dict(self) -&gt; dict:\n\"\"\"\n        Convert the MetricWatcherSetup object to a dictionary\n        Returns:\n            dict: The dictionary representation of the object\n        \"\"\"\nreturn self.__dict__\ndef upsert_dimensions(self, dimensions_specs: Optional[List[str]] = None):\n\"\"\"\n        Upsert the dimensions list with the dimensions specified in the environment\n        Args:\n            dimensions_specs (List[str]): A list of strings. Format: \"Name:Value\"\n        \"\"\"\nif dimensions_specs is None:\nreturn\nfor dimension_spec in dimensions_specs:\nname, value = dimension_spec.split(\":\")\nfor dimension in self.dimensions_list:\nif dimension.Name == name:\ndimension.Value = value\nbreak\nelse:\nself.dimensions_list.append(Dimension(Name=name, Value=value))\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Create a MetricWatcherSetup object from a dictionary</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>The dictionary to use</p> required Source code in <code>cloudwatcher/preset.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: dict) -&gt; \"MetricWatcherSetup\":\n\"\"\"\n    Create a MetricWatcherSetup object from a dictionary\n    Args:\n        data (dict): The dictionary to use\n    \"\"\"\nreturn cls(**data)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.from_json","title":"<code>from_json(file_path)</code>  <code>classmethod</code>","text":"<p>Create a MetricWatcherSetup object from a JSON file</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the JSON file</p> required Source code in <code>cloudwatcher/preset.py</code> <pre><code>@classmethod\ndef from_json(cls, file_path: Path) -&gt; \"MetricWatcherSetup\":\n\"\"\"\n    Create a MetricWatcherSetup object from a JSON file\n    Args:\n        file_path (str): The path to the JSON file\n    \"\"\"\nwith open(file_path) as f:\ndata = json.load(f)\nreturn cls.from_dict(data)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the MetricWatcherSetup object to a dictionary</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the object</p> Source code in <code>cloudwatcher/preset.py</code> <pre><code>def to_dict(self) -&gt; dict:\n\"\"\"\n    Convert the MetricWatcherSetup object to a dictionary\n    Returns:\n        dict: The dictionary representation of the object\n    \"\"\"\nreturn self.__dict__\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.MetricWatcherSetup.upsert_dimensions","title":"<code>upsert_dimensions(dimensions_specs=None)</code>","text":"<p>Upsert the dimensions list with the dimensions specified in the environment</p> <p>Parameters:</p> Name Type Description Default <code>dimensions_specs</code> <code>List[str]</code> <p>A list of strings. Format: \"Name:Value\"</p> <code>None</code> Source code in <code>cloudwatcher/preset.py</code> <pre><code>def upsert_dimensions(self, dimensions_specs: Optional[List[str]] = None):\n\"\"\"\n    Upsert the dimensions list with the dimensions specified in the environment\n    Args:\n        dimensions_specs (List[str]): A list of strings. Format: \"Name:Value\"\n    \"\"\"\nif dimensions_specs is None:\nreturn\nfor dimension_spec in dimensions_specs:\nname, value = dimension_spec.split(\":\")\nfor dimension in self.dimensions_list:\nif dimension.Name == name:\ndimension.Value = value\nbreak\nelse:\nself.dimensions_list.append(Dimension(Name=name, Value=value))\n</code></pre>"},{"location":"API_documentation/#presetfilesinventory","title":"<code>PresetFilesInventory</code>","text":"Source code in <code>cloudwatcher/preset.py</code> <pre><code>class PresetFilesInventory:\ndef __init__(self, presets_dir: Optional[Union[Path, str]] = None) -&gt; None:\n\"\"\"\n        Initialize the preset inventory\n        Args:\n            presets_dir (Path): The path to the presets directory\n        Raises:\n            ValueError: If the presets directory does not exist\n        \"\"\"\npreset_dir = (\nPath(presets_dir)\nif presets_dir is not None\nelse Path(__file__).parent / \"presets\"\n)\nif not preset_dir.exists():\nraise ValueError(f\"Presets directory {preset_dir} does not exist\")\nself._presets_dir = preset_dir\n_LOGGER.debug(f\"Presets directory: {self.presets_dir}\")\nself._presets = self._get_available_presets(self.presets_dir)\ndef _get_available_presets(self, presets_dir: Path) -&gt; Dict[str, Path]:\nreturn {\npreset_file.stem: preset_file\nfor preset_file in presets_dir.iterdir()\nif preset_file.is_file() and preset_file.suffix == \".json\"\n}\n@property\ndef presets_table(self) -&gt; Table:\n\"\"\"\n        Get a rich table with the available presets\n        Returns:\n            Table: The rich table\n        \"\"\"\ntable = Table(show_header=True, header_style=\"bold magenta\")\ntable.add_column(\"Name\")\ntable.add_column(\"Path\", style=\"dim\")\nfor preset_name, preset_path in self.presets.items():\ntable.add_row(preset_name, preset_path.as_posix())\ntable.title = f\"Presets available in: {self.presets_dir}\"\nreturn table\n@property\ndef presets(self) -&gt; Dict[str, Path]:\n\"\"\"\n        Get the available presets\n        Returns:\n            Dict[str, Path]: The available presets\n        \"\"\"\nreturn self._presets\n@property\ndef presets_list(self) -&gt; List[str]:\n\"\"\"\n        Get the list of available presets\n        Returns:\n            List[str]: The list of available presets\n        \"\"\"\nreturn list(self._presets.keys())\n@property\ndef presets_dir(self) -&gt; Path:\n\"\"\"\n        Get the presets directory\n        Returns:\n            Path: The presets directory\n        \"\"\"\nreturn self._presets_dir\ndef get_preset_path(self, preset_name: str) -&gt; Path:\n\"\"\"\n        Get the preset file content\n        Args:\n            preset_name (str): The name of the preset\n        Returns:\n            Path: the path to the preset file\n        \"\"\"\nif preset_name not in self.presets:\nraise ValueError(\nf\"Preset {preset_name} not found. Available presets: \"\nf\"{', '.join(self.presets.keys())}\"\n)\nreturn self.presets[preset_name]\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets","title":"<code>presets: Dict[str, Path]</code>  <code>property</code>","text":"<p>Get the available presets</p> <p>Returns:</p> Type Description <code>Dict[str, Path]</code> <p>Dict[str, Path]: The available presets</p>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_dir","title":"<code>presets_dir: Path</code>  <code>property</code>","text":"<p>Get the presets directory</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The presets directory</p>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_list","title":"<code>presets_list: List[str]</code>  <code>property</code>","text":"<p>Get the list of available presets</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: The list of available presets</p>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.presets_table","title":"<code>presets_table: Table</code>  <code>property</code>","text":"<p>Get a rich table with the available presets</p> <p>Returns:</p> Name Type Description <code>Table</code> <code>Table</code> <p>The rich table</p>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.__init__","title":"<code>__init__(presets_dir=None)</code>","text":"<p>Initialize the preset inventory</p> <p>Parameters:</p> Name Type Description Default <code>presets_dir</code> <code>Path</code> <p>The path to the presets directory</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the presets directory does not exist</p> Source code in <code>cloudwatcher/preset.py</code> <pre><code>def __init__(self, presets_dir: Optional[Union[Path, str]] = None) -&gt; None:\n\"\"\"\n    Initialize the preset inventory\n    Args:\n        presets_dir (Path): The path to the presets directory\n    Raises:\n        ValueError: If the presets directory does not exist\n    \"\"\"\npreset_dir = (\nPath(presets_dir)\nif presets_dir is not None\nelse Path(__file__).parent / \"presets\"\n)\nif not preset_dir.exists():\nraise ValueError(f\"Presets directory {preset_dir} does not exist\")\nself._presets_dir = preset_dir\n_LOGGER.debug(f\"Presets directory: {self.presets_dir}\")\nself._presets = self._get_available_presets(self.presets_dir)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.preset.PresetFilesInventory.get_preset_path","title":"<code>get_preset_path(preset_name)</code>","text":"<p>Get the preset file content</p> <p>Parameters:</p> Name Type Description Default <code>preset_name</code> <code>str</code> <p>The name of the preset</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>the path to the preset file</p> Source code in <code>cloudwatcher/preset.py</code> <pre><code>def get_preset_path(self, preset_name: str) -&gt; Path:\n\"\"\"\n    Get the preset file content\n    Args:\n        preset_name (str): The name of the preset\n    Returns:\n        Path: the path to the preset file\n    \"\"\"\nif preset_name not in self.presets:\nraise ValueError(\nf\"Preset {preset_name} not found. Available presets: \"\nf\"{', '.join(self.presets.keys())}\"\n)\nreturn self.presets[preset_name]\n</code></pre>"},{"location":"API_documentation/#metric-handlers","title":"Metric handlers","text":""},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseHandler","title":"<code>ResponseHandler</code>","text":"<p>Abstract class to establish the interface for a response handling</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class ResponseHandler:\n\"\"\"\n    Abstract class to establish the interface for a response handling\n    \"\"\"\ndef __init__(self, response: dict) -&gt; None:\n\"\"\"\n        Initialize the handler\n        Args:\n            response (dict): The response from the AWS API\n        \"\"\"\nself.response = response\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseHandler.__init__","title":"<code>__init__(response)</code>","text":"<p>Initialize the handler</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>dict</code> <p>The response from the AWS API</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __init__(self, response: dict) -&gt; None:\n\"\"\"\n    Initialize the handler\n    Args:\n        response (dict): The response from the AWS API\n    \"\"\"\nself.response = response\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseLogger","title":"<code>ResponseLogger</code>","text":"<p>         Bases: <code>ResponseHandler</code></p> <p>Log the response to the console</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class ResponseLogger(ResponseHandler):\n\"\"\"\n    Log the response to the console\n    \"\"\"\ndef __call__(self, target: str) -&gt; None:\nif target is not None:\nraise NotImplementedError(\n\"Logging responses to a file is not yet implemented.\"\n)\n_LOGGER.debug(json.dumps(self.response, indent=4, default=str))\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseSaver","title":"<code>ResponseSaver</code>","text":"<p>         Bases: <code>ResponseHandler</code></p> <p>Save the response to a file</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class ResponseSaver(ResponseHandler):\n\"\"\"\n    Save the response to a file\n    \"\"\"\ndef __call__(self, target: str) -&gt; None:\n\"\"\"\n        Save the response to a file\n        Args:\n            target (str): The target file to save the response to\n        \"\"\"\nwith open(target, \"w\") as f:\njson.dump(self.response, f, indent=4, default=str)\n_LOGGER.info(f\"Saved response to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.ResponseSaver.__call__","title":"<code>__call__(target)</code>","text":"<p>Save the response to a file</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target file to save the response to</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(self, target: str) -&gt; None:\n\"\"\"\n    Save the response to a file\n    Args:\n        target (str): The target file to save the response to\n    \"\"\"\nwith open(target, \"w\") as f:\njson.dump(self.response, f, indent=4, default=str)\n_LOGGER.info(f\"Saved response to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetric","title":"<code>TimedMetric</code>  <code>dataclass</code>","text":"<p>Timed metric object</p> <p>Parameters:</p> Name Type Description Default <code>timestamps</code> <code>List[datetime]</code> <p>The timestamps of the metric</p> required <code>values</code> <code>List[float]</code> <p>The values of the metric</p> required <code>label</code> <code>str</code> <p>The label of the metric</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>@dataclass\nclass TimedMetric:\n\"\"\"\n    Timed metric object\n    Args:\n        timestamps (List[datetime]): The timestamps of the metric\n        values (List[float]): The values of the metric\n        label (str): The label of the metric\n    \"\"\"\nlabel: str\ntimestamps: List[datetime]\nvalues: List[float]\ndef __len__(self):\nif len(self.timestamps) == len(self.values):\nreturn len(self.values)\nraise ValueError(\"The internal timed metric lengths are not equal\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricCsvSaver","title":"<code>TimedMetricCsvSaver</code>","text":"<p>         Bases: <code>TimedMetricHandler</code></p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricCsvSaver(TimedMetricHandler):\ndef __call__(self, target: str) -&gt; None:\n\"\"\"\n        Write the object to a csv file\n        Args:\n            target (str): The target file to save the object to\n        \"\"\"\nwith open(target, \"w\", encoding=\"UTF8\", newline=\"\") as f:\nwriter = csv.writer(f)\n# write the header\nwriter.writerow([\"time\", \"value\"])\n# write the data\nfor i in range(len(self.timed_metric)):\nwriter.writerow(\n[self.timed_metric.timestamps[i], self.timed_metric.values[i]]\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' data to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricCsvSaver.__call__","title":"<code>__call__(target)</code>","text":"<p>Write the object to a csv file</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target file to save the object to</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(self, target: str) -&gt; None:\n\"\"\"\n    Write the object to a csv file\n    Args:\n        target (str): The target file to save the object to\n    \"\"\"\nwith open(target, \"w\", encoding=\"UTF8\", newline=\"\") as f:\nwriter = csv.writer(f)\n# write the header\nwriter.writerow([\"time\", \"value\"])\n# write the data\nfor i in range(len(self.timed_metric)):\nwriter.writerow(\n[self.timed_metric.timestamps[i], self.timed_metric.values[i]]\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' data to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricHandler","title":"<code>TimedMetricHandler</code>","text":"<p>Class to establish the interface for a timed metric handling</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricHandler:\n\"\"\"\n    Class to establish the interface for a timed metric handling\n    \"\"\"\ndef __init__(self, timed_metric: TimedMetric) -&gt; None:\n\"\"\"\n        Initialize the handler\n        Args:\n            timed_metric (TimedMetric): The timed metric to use\n        \"\"\"\nself.timed_metric = timed_metric\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricHandler.__init__","title":"<code>__init__(timed_metric)</code>","text":"<p>Initialize the handler</p> <p>Parameters:</p> Name Type Description Default <code>timed_metric</code> <code>TimedMetric</code> <p>The timed metric to use</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __init__(self, timed_metric: TimedMetric) -&gt; None:\n\"\"\"\n    Initialize the handler\n    Args:\n        timed_metric (TimedMetric): The timed metric to use\n    \"\"\"\nself.timed_metric = timed_metric\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricJsonSaver","title":"<code>TimedMetricJsonSaver</code>","text":"<p>         Bases: <code>TimedMetricHandler</code></p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricJsonSaver(TimedMetricHandler):\ndef __call__(self, target: str) -&gt; None:\n\"\"\"\n        Write the object to a json file\n        Args:\n            target (str): The target file to save the object to\n        \"\"\"\nwith open(target, \"w\") as f:\njson.dump(\n{\n\"Label\": self.timed_metric.label,\n\"Timestamps\": self.timed_metric.timestamps,\n\"Values\": self.timed_metric.values,\n},\nf,\nindent=4,\ndefault=str,\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' data to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricJsonSaver.__call__","title":"<code>__call__(target)</code>","text":"<p>Write the object to a json file</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target file to save the object to</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(self, target: str) -&gt; None:\n\"\"\"\n    Write the object to a json file\n    Args:\n        target (str): The target file to save the object to\n    \"\"\"\nwith open(target, \"w\") as f:\njson.dump(\n{\n\"Label\": self.timed_metric.label,\n\"Timestamps\": self.timed_metric.timestamps,\n\"Values\": self.timed_metric.values,\n},\nf,\nindent=4,\ndefault=str,\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' data to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger","title":"<code>TimedMetricLogger</code>","text":"<p>         Bases: <code>TimedMetricHandler</code></p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricLogger(TimedMetricHandler):\ndef __call__(self, target: str) -&gt; None:\n\"\"\"\n        Log the timed metric as a table\n        \"\"\"\nif target is not None:\nraise NotImplementedError(\"Logging to a file is not yet implemented.\")\ntable = Table(show_header=True, header_style=\"bold magenta\")\ntable.add_column(f\"Time ({str(pytz.utc)})\", style=\"dim\", justify=\"center\")\ntable.add_column(\"Value\")\nvalues = [\nself.mem_to_str(v) if self.timed_metric.label.startswith(\"mem\") else str(v)\nfor v in self.timed_metric.values\n]\nfor i in range(len(self.timed_metric.timestamps)):\ntable.add_row(\nself.timed_metric.timestamps[i].strftime(\"%H:%M:%S\"), values[i]\n)\nconsole = Console()\nconsole.print(table)\n@staticmethod\ndef mem_to_str(size: float, precision: int = 3) -&gt; str:\n\"\"\"\n        Convert bytes to human readable string\n        Args:\n            size (int): The size in bytes\n            precision (int): The precision to use, number of decimal places\n        Returns:\n            str: The human readable string\n        \"\"\"\nsize, suffix = convert_mem(size)\nreturn \"%.*f %s\" % (precision, size, suffix)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger.__call__","title":"<code>__call__(target)</code>","text":"<p>Log the timed metric as a table</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(self, target: str) -&gt; None:\n\"\"\"\n    Log the timed metric as a table\n    \"\"\"\nif target is not None:\nraise NotImplementedError(\"Logging to a file is not yet implemented.\")\ntable = Table(show_header=True, header_style=\"bold magenta\")\ntable.add_column(f\"Time ({str(pytz.utc)})\", style=\"dim\", justify=\"center\")\ntable.add_column(\"Value\")\nvalues = [\nself.mem_to_str(v) if self.timed_metric.label.startswith(\"mem\") else str(v)\nfor v in self.timed_metric.values\n]\nfor i in range(len(self.timed_metric.timestamps)):\ntable.add_row(\nself.timed_metric.timestamps[i].strftime(\"%H:%M:%S\"), values[i]\n)\nconsole = Console()\nconsole.print(table)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricLogger.mem_to_str","title":"<code>mem_to_str(size, precision=3)</code>  <code>staticmethod</code>","text":"<p>Convert bytes to human readable string</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>int</code> <p>The size in bytes</p> required <code>precision</code> <code>int</code> <p>The precision to use, number of decimal places</p> <code>3</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The human readable string</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>@staticmethod\ndef mem_to_str(size: float, precision: int = 3) -&gt; str:\n\"\"\"\n    Convert bytes to human readable string\n    Args:\n        size (int): The size in bytes\n        precision (int): The precision to use, number of decimal places\n    Returns:\n        str: The human readable string\n    \"\"\"\nsize, suffix = convert_mem(size)\nreturn \"%.*f %s\" % (precision, size, suffix)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricPlotter","title":"<code>TimedMetricPlotter</code>","text":"<p>         Bases: <code>TimedMetricHandler</code></p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricPlotter(TimedMetricHandler):\ndef __call__(self, target: str, metric_unit: str) -&gt; None:\n\"\"\"\n        Plot the timed metric\n        Args:\n            target (str): The target file to save the plot to\n            metric_unit (str): The unit of the metric\n        \"\"\"\nvalues = self.timed_metric.values\nif self.timed_metric.label.startswith(\"mem\") and metric_unit == \"Bytes\":\nmetric_unit = \"GB\"\nvalues = [convert_mem(v, force_suffix=metric_unit)[0] for v in values]\nplt.figure()\nplt.plot(\nself.timed_metric.timestamps,\nvalues,\nlinewidth=0.8,\n)\nplt.title(\nf\"{self.timed_metric.label} over time\",\nloc=\"right\",\nfontstyle=\"italic\",\n)\nplt.ylabel(f\"{self.timed_metric.label} ({metric_unit})\")\nplt.ticklabel_format(axis=\"y\", style=\"plain\", useOffset=False)\nplt.tick_params(left=True, bottom=False, labelleft=True, labelbottom=False)\nplt.savefig(\ntarget,\nbbox_inches=\"tight\",\npad_inches=0.1,\ndpi=300,\nformat=\"png\",\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' plot to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricPlotter.__call__","title":"<code>__call__(target, metric_unit)</code>","text":"<p>Plot the timed metric</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target file to save the plot to</p> required <code>metric_unit</code> <code>str</code> <p>The unit of the metric</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(self, target: str, metric_unit: str) -&gt; None:\n\"\"\"\n    Plot the timed metric\n    Args:\n        target (str): The target file to save the plot to\n        metric_unit (str): The unit of the metric\n    \"\"\"\nvalues = self.timed_metric.values\nif self.timed_metric.label.startswith(\"mem\") and metric_unit == \"Bytes\":\nmetric_unit = \"GB\"\nvalues = [convert_mem(v, force_suffix=metric_unit)[0] for v in values]\nplt.figure()\nplt.plot(\nself.timed_metric.timestamps,\nvalues,\nlinewidth=0.8,\n)\nplt.title(\nf\"{self.timed_metric.label} over time\",\nloc=\"right\",\nfontstyle=\"italic\",\n)\nplt.ylabel(f\"{self.timed_metric.label} ({metric_unit})\")\nplt.ticklabel_format(axis=\"y\", style=\"plain\", useOffset=False)\nplt.tick_params(left=True, bottom=False, labelleft=True, labelbottom=False)\nplt.savefig(\ntarget,\nbbox_inches=\"tight\",\npad_inches=0.1,\ndpi=300,\nformat=\"png\",\n)\n_LOGGER.info(f\"Saved '{self.timed_metric.label}' plot to: {target}\")\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricSummarizer","title":"<code>TimedMetricSummarizer</code>","text":"<p>         Bases: <code>TimedMetricHandler</code></p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>class TimedMetricSummarizer(TimedMetricHandler):\ndef __call__(\nself,\ntarget: str,\nmetric_unit: str,\nsummarizer: Tuple[str, Callable],\n) -&gt; None:\n\"\"\"\n        Summarize the metric\n        Args:\n            target (str): The target file to save the summary to\n            metric_unit (str): The unit of the metric\n            summarizer (Tuple[str, callable]): The summarizer to use\n                and the function to use\n        \"\"\"\nif target is not None:\nraise NotImplementedError(\"Logging to a file is not yet implemented.\")\ntimespan = self.timed_metric.timestamps[0] - self.timed_metric.timestamps[-1]\n_LOGGER.info(\nf\"Retrieved '{self.timed_metric.label}' {len(self.timed_metric.values)} \"\nf\"measurements over {timespan} timespan\"\n)\nsummary = summarizer[1](self.timed_metric.values)\nif self.timed_metric.label.startswith(\"mem\") and metric_unit == \"Bytes\":\nmem, metric_unit = convert_mem(summary)\n_LOGGER.info(\nf\"{summarizer[0]} '{self.timed_metric.label}' is \"\nf\"{mem:.2f} {metric_unit} over {timespan} timespan\"\n)\nelse:\n_LOGGER.info(\nf\"{summarizer[0]} '{self.timed_metric.label}' is \"\nf\"{summary} over {timespan} timespan\"\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.TimedMetricSummarizer.__call__","title":"<code>__call__(target, metric_unit, summarizer)</code>","text":"<p>Summarize the metric</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The target file to save the summary to</p> required <code>metric_unit</code> <code>str</code> <p>The unit of the metric</p> required <code>summarizer</code> <code>Tuple[str, callable]</code> <p>The summarizer to use and the function to use</p> required Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def __call__(\nself,\ntarget: str,\nmetric_unit: str,\nsummarizer: Tuple[str, Callable],\n) -&gt; None:\n\"\"\"\n    Summarize the metric\n    Args:\n        target (str): The target file to save the summary to\n        metric_unit (str): The unit of the metric\n        summarizer (Tuple[str, callable]): The summarizer to use\n            and the function to use\n    \"\"\"\nif target is not None:\nraise NotImplementedError(\"Logging to a file is not yet implemented.\")\ntimespan = self.timed_metric.timestamps[0] - self.timed_metric.timestamps[-1]\n_LOGGER.info(\nf\"Retrieved '{self.timed_metric.label}' {len(self.timed_metric.values)} \"\nf\"measurements over {timespan} timespan\"\n)\nsummary = summarizer[1](self.timed_metric.values)\nif self.timed_metric.label.startswith(\"mem\") and metric_unit == \"Bytes\":\nmem, metric_unit = convert_mem(summary)\n_LOGGER.info(\nf\"{summarizer[0]} '{self.timed_metric.label}' is \"\nf\"{mem:.2f} {metric_unit} over {timespan} timespan\"\n)\nelse:\n_LOGGER.info(\nf\"{summarizer[0]} '{self.timed_metric.label}' is \"\nf\"{summary} over {timespan} timespan\"\n)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.metric_handlers.convert_mem","title":"<code>convert_mem(value, force_suffix=None)</code>","text":"<p>Convert memory in bytes to the highest possible, or desired memory unit</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int</code> <p>The memory in bytes</p> required <code>force_suffix</code> <code>str</code> <p>The desired memory unit</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[float, str]</code> <p>Tuple[float, str]: The memory in the desired unit and the unit</p> Source code in <code>cloudwatcher/metric_handlers.py</code> <pre><code>def convert_mem(value: float, force_suffix: Optional[str] = None) -&gt; Tuple[float, str]:\n\"\"\"\n    Convert memory in bytes to the highest possible, or desired memory unit\n    Args:\n        value (int): The memory in bytes\n        force_suffix (str): The desired memory unit\n    Returns:\n        Tuple[float, str]: The memory in the desired unit and the unit\n    \"\"\"\nsuffixes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\"]\nif force_suffix is not None:\ntry:\nidx = suffixes.index(force_suffix)\nexcept ValueError:\nraise ValueError(f\"Forced memory unit must me one of: {suffixes}\")\nelse:\nreturn value / float(pow(1024, idx)), force_suffix\nsuffixIndex = 0\nwhile value &gt; 1024 and suffixIndex &lt; len(suffixes) - 1:\nsuffixIndex += 1\nvalue /= 1024.0\nreturn value, suffixes[suffixIndex]\n</code></pre>"},{"location":"API_documentation/#logevent","title":"<code>LogEvent</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>A class for AWS CloudWatch log events</p> <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>The log message</p> <code>timestamp</code> <code>datetime</code> <p>The log timestamp</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>class LogEvent(BaseModel):\n\"\"\"\n    A class for AWS CloudWatch log events\n    Attributes:\n        message (str): The log message\n        timestamp (datetime): The log timestamp\n    \"\"\"\nmessage: str\ntimestamp: datetime\n@classmethod\ndef from_response(cls, response: Dict[str, Any]) -&gt; \"LogEvent\":\n\"\"\"\n        Create a LogEvent object from a response\n        Args:\n            response (Dict[str, Any]): The response from AWS\n        Returns:\n            LogEvent: The LogEvent object\n        \"\"\"\nreturn cls(\nmessage=response[\"message\"],\ntimestamp=datetime.fromtimestamp(response[\"timestamp\"] / 1000),\n)\ndef format_message(\nself,\nregex: Optional[str] = None,\nfmt_str_log: Optional[str] = None,\nfmt_str_datetime: Optional[str] = None,\n) -&gt; \"LogEvent\":\n\"\"\"\n        Format the message by removing the embedded timestamp and adding a UTC timestamp\n        Args:\n            regex (str): regex to match the timestamp in the message\n            fmt_str_log (str): format string for the log message\n            fmt_str_datetime (str): format string for the datetime\n        Returns:\n            str: formatted message\n        \"\"\"\nregex = regex or r\"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\"\nfmt_str_log = fmt_str_log or \"[{time} UTC] {message}\"\nfmt_str_datetime = fmt_str_datetime or \"%d-%m-%Y %H:%M:%S\"\nm = re.search(regex, self.message)\nmsg = self.message[m.end() :] if m else self.message\nformatted_message = fmt_str_log.format(\ntime=self.timestamp.strftime(fmt_str_datetime), message=msg.strip()\n)\nreturn LogEvent(message=formatted_message, timestamp=self.timestamp)\ndef __bool__(self) -&gt; bool:\n\"\"\"\n        Return True if the message is not empty\n        Returns:\n            bool: True if the message is not empty\n        \"\"\"\nreturn bool(self.message)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEvent.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the message is not empty</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the message is not empty</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Return True if the message is not empty\n    Returns:\n        bool: True if the message is not empty\n    \"\"\"\nreturn bool(self.message)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEvent.format_message","title":"<code>format_message(regex=None, fmt_str_log=None, fmt_str_datetime=None)</code>","text":"<p>Format the message by removing the embedded timestamp and adding a UTC timestamp</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex to match the timestamp in the message</p> <code>None</code> <code>fmt_str_log</code> <code>str</code> <p>format string for the log message</p> <code>None</code> <code>fmt_str_datetime</code> <code>str</code> <p>format string for the datetime</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>LogEvent</code> <p>formatted message</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def format_message(\nself,\nregex: Optional[str] = None,\nfmt_str_log: Optional[str] = None,\nfmt_str_datetime: Optional[str] = None,\n) -&gt; \"LogEvent\":\n\"\"\"\n    Format the message by removing the embedded timestamp and adding a UTC timestamp\n    Args:\n        regex (str): regex to match the timestamp in the message\n        fmt_str_log (str): format string for the log message\n        fmt_str_datetime (str): format string for the datetime\n    Returns:\n        str: formatted message\n    \"\"\"\nregex = regex or r\"^\\[\\d+-\\d+-\\d+\\s\\d+:\\d+:\\d+(.|,)\\d+(\\]|\\s-\\s\\w+\\])\"\nfmt_str_log = fmt_str_log or \"[{time} UTC] {message}\"\nfmt_str_datetime = fmt_str_datetime or \"%d-%m-%Y %H:%M:%S\"\nm = re.search(regex, self.message)\nmsg = self.message[m.end() :] if m else self.message\nformatted_message = fmt_str_log.format(\ntime=self.timestamp.strftime(fmt_str_datetime), message=msg.strip()\n)\nreturn LogEvent(message=formatted_message, timestamp=self.timestamp)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEvent.from_response","title":"<code>from_response(response)</code>  <code>classmethod</code>","text":"<p>Create a LogEvent object from a response</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Dict[str, Any]</code> <p>The response from AWS</p> required <p>Returns:</p> Name Type Description <code>LogEvent</code> <code>LogEvent</code> <p>The LogEvent object</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>@classmethod\ndef from_response(cls, response: Dict[str, Any]) -&gt; \"LogEvent\":\n\"\"\"\n    Create a LogEvent object from a response\n    Args:\n        response (Dict[str, Any]): The response from AWS\n    Returns:\n        LogEvent: The LogEvent object\n    \"\"\"\nreturn cls(\nmessage=response[\"message\"],\ntimestamp=datetime.fromtimestamp(response[\"timestamp\"] / 1000),\n)\n</code></pre>"},{"location":"API_documentation/#logeventslist","title":"<code>LogEventsList</code>","text":"<p>         Bases: <code>BaseModel</code></p> <p>A class for AWS CloudWatch log events list</p> <p>Attributes:</p> Name Type Description <code>events</code> <code>List[LogEvent]</code> <p>The list of log events</p> <code>next_forward_token</code> <code>Optional[str]</code> <p>The next forward token</p> <code>next_backward_token</code> <code>Optional[str]</code> <p>The next backward token</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>class LogEventsList(BaseModel):\n\"\"\"\n    A class for AWS CloudWatch log events list\n    Attributes:\n        events (List[LogEvent]): The list of log events\n        next_forward_token (Optional[str]): The next forward token\n        next_backward_token (Optional[str]): The next backward token\n    \"\"\"\nevents: List[LogEvent]\nnext_forward_token: Optional[str]\nnext_backward_token: Optional[str]\n@classmethod\ndef from_response(cls, response: Dict[str, Any]) -&gt; \"LogEventsList\":\n\"\"\"\n        Create a LogEventsList object from a response\n        Args:\n            response (Dict[str, Any]): The response from AWS\n        Returns:\n            LogEventsList: The LogEventsList object\n        \"\"\"\nreturn cls(\nevents=[LogEvent.from_response(event) for event in response[\"events\"]],\nnext_forward_token=response.get(\"nextForwardToken\"),\nnext_backward_token=response.get(\"nextBackwardToken\"),\n)\ndef format_messages(\nself,\nregex: Optional[str] = None,\nfmt_str_datetime: Optional[str] = None,\nfmt_str_log: Optional[str] = None,\n) -&gt; \"LogEventsList\":\n\"\"\"\n        Format the messages by removing the embedded timestamp\n        and adding a UTC timestamp\n        Args:\n            regex (str): regex to match the timestamp in the message\n            fmt_str_log (str): format string for the log message\n            fmt_str_datetime (str): format string for the datetime\n        Returns:\n            LogEventsList: The LogEventsList object, with formatted messages\n        \"\"\"\nself.events = [\nevent.format_message(\nregex=regex, fmt_str_datetime=fmt_str_datetime, fmt_str_log=fmt_str_log\n)\nfor event in self.events\n]\nreturn self\ndef __bool__(self) -&gt; bool:\n\"\"\"\n        Return True if the events list is not empty\n        Returns:\n            bool: True if the events list is not empty\n        \"\"\"\nreturn bool(self.events)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEventsList.__bool__","title":"<code>__bool__()</code>","text":"<p>Return True if the events list is not empty</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the events list is not empty</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def __bool__(self) -&gt; bool:\n\"\"\"\n    Return True if the events list is not empty\n    Returns:\n        bool: True if the events list is not empty\n    \"\"\"\nreturn bool(self.events)\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEventsList.format_messages","title":"<code>format_messages(regex=None, fmt_str_datetime=None, fmt_str_log=None)</code>","text":"<p>Format the messages by removing the embedded timestamp and adding a UTC timestamp</p> <p>Parameters:</p> Name Type Description Default <code>regex</code> <code>str</code> <p>regex to match the timestamp in the message</p> <code>None</code> <code>fmt_str_log</code> <code>str</code> <p>format string for the log message</p> <code>None</code> <code>fmt_str_datetime</code> <code>str</code> <p>format string for the datetime</p> <code>None</code> <p>Returns:</p> Name Type Description <code>LogEventsList</code> <code>LogEventsList</code> <p>The LogEventsList object, with formatted messages</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>def format_messages(\nself,\nregex: Optional[str] = None,\nfmt_str_datetime: Optional[str] = None,\nfmt_str_log: Optional[str] = None,\n) -&gt; \"LogEventsList\":\n\"\"\"\n    Format the messages by removing the embedded timestamp\n    and adding a UTC timestamp\n    Args:\n        regex (str): regex to match the timestamp in the message\n        fmt_str_log (str): format string for the log message\n        fmt_str_datetime (str): format string for the datetime\n    Returns:\n        LogEventsList: The LogEventsList object, with formatted messages\n    \"\"\"\nself.events = [\nevent.format_message(\nregex=regex, fmt_str_datetime=fmt_str_datetime, fmt_str_log=fmt_str_log\n)\nfor event in self.events\n]\nreturn self\n</code></pre>"},{"location":"API_documentation/#cloudwatcher.logwatcher.LogEventsList.from_response","title":"<code>from_response(response)</code>  <code>classmethod</code>","text":"<p>Create a LogEventsList object from a response</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Dict[str, Any]</code> <p>The response from AWS</p> required <p>Returns:</p> Name Type Description <code>LogEventsList</code> <code>LogEventsList</code> <p>The LogEventsList object</p> Source code in <code>cloudwatcher/logwatcher.py</code> <pre><code>@classmethod\ndef from_response(cls, response: Dict[str, Any]) -&gt; \"LogEventsList\":\n\"\"\"\n    Create a LogEventsList object from a response\n    Args:\n        response (Dict[str, Any]): The response from AWS\n    Returns:\n        LogEventsList: The LogEventsList object\n    \"\"\"\nreturn cls(\nevents=[LogEvent.from_response(event) for event in response[\"events\"]],\nnext_forward_token=response.get(\"nextForwardToken\"),\nnext_backward_token=response.get(\"nextBackwardToken\"),\n)\n</code></pre>"},{"location":"API_usage/","title":"<code>cloudwatcher</code> Python API usage","text":"<p>The purpose of this page is to provide a quick overview of the <code>cloudwatcher</code> Python API. The package consists of two user-facing classes:</p> <ul> <li><code>MetricWatcher</code>: This class is used to interact with AWS CloudWatch metrics.</li> <li><code>LogWatcher</code>: This class is used to interact with AWS CloudWatch logs.</li> </ul> <p>Both of these classes inherit from the <code>CloudWatcher</code> class.</p>"},{"location":"API_usage/#metricwatcher-convenient-interface-to-aws-cloudwatch-metrics","title":"<code>MetricWatcher</code>: convenient interface to AWS CloudWatch metrics","text":"<p><code>MetricWatcher</code> can be used to interact with AWS CloudWatch metrics. </p>"},{"location":"API_usage/#metricwatcher-initialization","title":"<code>MetricWatcher</code> initialization","text":"<p>As described in the Login credentials section, the AWS credentials can be sourced from environment variables: <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>. Alternatively, you can pass the values as arguments to the <code>MetricWatcher</code> constructor.</p> <pre><code>from cloudwatcher.metricwatcher import MetricWatcher\nfrom cloudwatcher.preset import Dimension\nfrom dotenv import load_dotenv\nimport os\nload_dotenv()\ninstance_id = os.environ.get(\"INSTANCE_ID\")\nmw = MetricWatcher(\nnamespace=\"NepheleNamespaceEC2\",\nmetric_name=\"mem_used\",\nmetric_id=\"mem_used\",\nmetric_unit=\"Bytes\",\ndimensions_list=[Dimension(Name=\"InstanceId\", Value=instance_id)],\n)\n</code></pre>"},{"location":"API_usage/#metricwatcher-presets","title":"<code>MetricWatcher</code> presets","text":"<p>As you can see there are multiple arguments that can be passed to <code>MetricWatcher</code> constructor. In order to improve the UX when using <code>MetricWatcher</code> <code>cloudwatcher</code> package provides a few presets that can be used to query the data reported by <code>CloudWatchAgent</code> within certain systems. Additionally, custom presets can be defined by the user and used in the same way.</p> <p>Presets are JSON-formatted files that provide parameter bundles for <code>MetricWatcher</code> initialization.</p>"},{"location":"API_usage/#usage","title":"Usage","text":"<p>Listing available presets:</p> <pre><code>from cloudwatcher.preset import PresetFilesInventory\nfrom rich.console import Console\npfi = PresetFilesInventory()\nConsole().print(pfi.presets_table)\n</code></pre> <pre>                 Presets available in: /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets                  \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name                                   \u2503 Path                                                                   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 nephele_disk_used_percent              \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502\n\u2502 nephele_mem_cached                     \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502\n\u2502 nephele_mem                            \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_me\u2026 \u2502\n\u2502 nephele_disk_used_percent_nephele_data \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_di\u2026 \u2502\n\u2502 nephele_cpu_usage_user                 \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_cp\u2026 \u2502\n\u2502 nephele_processes_dead                 \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_pr\u2026 \u2502\n\u2502 nephele_swap_used_percent              \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502\n\u2502 nephele_swap_used                      \u2502 /Users/stolarczykmj/code/cloudwatcher/cloudwatcher/presets/nephele_sw\u2026 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</pre> <p>Using a preset:</p> <pre><code>from cloudwatcher.preset import MetricWatcherSetup\nmw_setup = MetricWatcherSetup.from_json(pfi.get_preset_path(\"nephele_mem\"))\nmw_setup.upsert_dimensions([f\"InstanceId:{instance_id}\"])\nmw = MetricWatcher(**mw_setup.to_dict())\nquery_kwargs = {\n\"days\": 5,\n\"hours\": 0,\n\"minutes\": 0,\n\"stat\": \"Maximum\",\n\"period\": 60,\n}\nresponse = mw.query_ec2_metrics(**query_kwargs)\nprint(response)\n</code></pre> <pre><code>{'MetricDataResults': [{'Id': 'nephele', 'Label': 'mem_used', 'Timestamps': [], 'Values': [], 'StatusCode': 'Complete'}], 'Messages': [], 'ResponseMetadata': {'RequestId': '6f543152-1547-4c3f-a1ec-8d904e28dba2', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': '6f543152-1547-4c3f-a1ec-8d904e28dba2', 'content-type': 'text/xml', 'content-length': '496', 'date': 'Mon, 31 Jul 2023 13:51:13 GMT'}, 'RetryAttempts': 0}}\n</code></pre>"},{"location":"API_usage/#querying-aws-cloudwatch-metrics","title":"Querying AWS CloudWatch metrics","text":"<p>In order to specify the EC2 instace query settings (period, granularity, etc.), the user would need to provide multiple parameters. To make it easier, there are a few sensible presets that can be used to select the query settings, which are passed to <code>query_ec2_metrics</code> method. These presets are defined to query the data reported by <code>CloudWatchAgent</code> within the last day, hour or minute.</p> <p>The presets can be used by passing the <code>query_preset</code> argument to the functions presented below. Alternatively, users can pass <code>query_kwargs</code> argument, which overrides the preset values.</p>"},{"location":"API_usage/#logging-methods","title":"Logging methods","text":"<p>There is a method that can be used to log the metric to the screen. The EC2 instance is automatically queried if the query response is not provided.</p>"},{"location":"API_usage/#file-saving-methods","title":"File saving methods","text":"<p>There are number of methods that can be used to save the metric data to a file. Again, the EC2 instance is automatically queried if the query response is not provided.</p> <pre><code>mw.save_metric_plot(file_path=f\"/tmp/{instance_id}_plot.png\", query_kwargs=query_kwargs)\nmw.save_metric_csv(file_path=f\"/tmp/{instance_id}_metric.csv\", query_kwargs=query_kwargs)\nmw.save_metric_json(file_path=f\"/tmp/{instance_id}_metric.json\", query_kwargs=query_kwargs)\nmw.save_response_json(file_path=f\"/tmp/{instance_id}_response.json\", query_kwargs=query_kwargs)\n</code></pre>"},{"location":"API_usage/#manual-ec2-querying","title":"Manual EC2 querying","text":"<p>For users that require more control over the EC2 instance query settings, the <code>query_ec2_metrics</code> method can be used to manually query the EC2 instance. For instance it allows to fine tune the query period settings.</p> <pre><code>FINE_TUNED_SETTINGS = {\n\"days\": 7,\n\"hours\": 0,\n\"minutes\": 0,\n\"stat\": \"Maximum\",\n\"period\": 60,\n}\nresponse = mw.query_ec2_metrics(**FINE_TUNED_SETTINGS)\nresponse[\"ResponseMetadata\"]\n</code></pre> <pre><code>{'RequestId': 'a59814d4-5445-4cb8-b539-9efb7d65716f',\n 'HTTPStatusCode': 200,\n 'HTTPHeaders': {'x-amzn-requestid': 'a59814d4-5445-4cb8-b539-9efb7d65716f',\n  'content-type': 'text/xml',\n  'content-length': '4418',\n  'date': 'Mon, 31 Jul 2023 13:51:13 GMT'},\n 'RetryAttempts': 0}\n</code></pre>"},{"location":"API_usage/#timedmetric-dataclass","title":"<code>TimedMetric</code> dataclass","text":"<p>Internally, the package uses <code>TimedMetric</code> dataclass to store the metric data. This dataclass is used to store the metric data and provide a convenient interface to access the data. It can be also used to interact with the metric data by the user.</p> <pre><code>response = mw.query_ec2_metrics(**FINE_TUNED_SETTINGS)\ntimed_metric = mw.timed_metric_factory(response)[0]\nprint(timed_metric.__class__)\ntimed_metric.values[1:10]\n</code></pre> <pre><code>&lt;class 'cloudwatcher.metric_handlers.TimedMetric'&gt;\n\n\n\n\n\n[1051193344.0,\n 22160080896.0,\n 29538459648.0,\n 29531140096.0,\n 17124524032.0,\n 29451448320.0,\n 17050480640.0,\n 29373624320.0,\n 29358415872.0]\n</code></pre>"},{"location":"API_usage/#logwatcher-convenient-interface-to-aws-cloudwatch-logs","title":"<code>LogWatcher</code>: convenient interface to AWS CloudWatch logs","text":"<p><code>LogWatcher</code> can be used to interact with AWS CloudWatch logs.</p>"},{"location":"API_usage/#logwatcher-initialization","title":"<code>LogWatcher</code> initialization","text":"<p>As described in the Login credentials section, the AWS credentials can be sourced from environment variables: <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>. Alternatively, you can pass the values as arguments to the <code>LogWatcher</code> constructor.</p> <pre><code>from cloudwatcher.logwatcher import LogWatcher\nfrom dotenv import load_dotenv\nimport os\nload_dotenv()\nx=os.environ.get(\"LOG_GROUP_NAME\")\ny=os.environ.get(\"LOG_STREAM_NAME\")\nprint(f\"LOG_GROUP_NAME: {x}\")\nprint(f\"LOG_STREAM_NAME: {y}\")\nlw = LogWatcher(\nlog_group_name=os.environ.get(\"LOG_GROUP_NAME\"),\nlog_stream_name=os.environ.get(\"LOG_STREAM_NAME\"),\n)\n</code></pre> <pre><code>LOG_GROUP_NAME: main-NepheleWorker\nLOG_STREAM_NAME: i-05cec4924aadbd516-job.log\n</code></pre> <p>Importantly, you can also provide the start token for the log, which will be used to determine the starting point of the log query.</p>"},{"location":"API_usage/#log-streaming","title":"Log streaming","text":"<p><code>LogWatcher</code> provides a convenient interface to stream the logs from AWS CloudWatch. There are 2 relevant parameters in <code>stream_cloudwatch_logs</code> method:</p> <ul> <li><code>events_limit</code> - the maximum number of events to be returned. If the value is set to <code>None</code>, 1000 events are returned</li> <li><code>max_retry_attempts</code> - the maximum number of retry attempts to be made if the query results with an empty log</li> </ul> <p>The <code>stream_cloudwatch_logs</code> method returns a generator that yields the log events, for example in a <code>for</code> loop. In the example below , we use <code>next</code> to get the first event from the generator.</p> <pre><code>streamer = lw.stream_cloudwatch_logs(events_limit=2, max_retry_attempts=2)\nnext(streamer)\n</code></pre> <pre><code>LogEventsList(events=[LogEvent(message='[2023-07-25 12:58:13,421 - INFO] Nephele, developed by BCBB/OCICB/NIAID/NIH version: 2.27.1, tag: Nephele_2023_July_19, commit: 0b87cad', timestamp=datetime.datetime(2023, 7, 25, 12, 58, 14, 403000)), LogEvent(message='[2023-07-25 12:58:13,421 - INFO] Python version: 3.7.3', timestamp=datetime.datetime(2023, 7, 25, 12, 58, 14, 403000))], next_forward_token='f/37695045377463395103684887982714400219916480157627908097/s', next_backward_token='b/37695045377463395103684887982714400219916480157627908096/s')\n</code></pre> <p>The log events are returned as a custom <code>LogEventsList</code> object, which conists of a list of <code>LogEvents</code> and tokens. The next token (<code>LogEventsList.next_forward_token</code>) can be used to get the next batch of log events. The token can be provided to the <code>LogWatcher</code> constructor to start streaming from the last event.</p>"},{"location":"API_usage/#retrieving-all-logs","title":"Retrieving all logs","text":"<p>Alternatively, the <code>return_formatted_logs</code> method can be used to retrieve all the logs. This method returns a <code>Tuple[str,str]</code>, where the first element is the formatted log and the second element is the next token. </p> <pre><code>formatted_logs, token = lw.return_formatted_logs()\nprint(formatted_logs)\n</code></pre> <pre><code>[25-07-2023 12:58:14 UTC] Nephele, developed by BCBB/OCICB/NIAID/NIH version: 2.27.1, tag: Nephele_2023_July_19, commit: 0b87cad\n[25-07-2023 12:58:14 UTC] Python version: 3.7.3\n[25-07-2023 12:58:14 UTC] Current time: 2023-07-25 12:58\n[25-07-2023 12:58:14 UTC] Pipeline name: Biobakery\n[25-07-2023 12:58:14 UTC] Job Description:\n[25-07-2023 12:58:14 UTC] Job parameters\n[25-07-2023 12:58:14 UTC] job_id: 5bfc066feb92\n[25-07-2023 12:58:14 UTC] map_file: &lt;_io.TextIOWrapper name='/nephele_data/inputs/N2_16S_example_mapping_one_corrected.txt' mode='r' encoding='latin-1'&gt;\n[25-07-2023 12:58:14 UTC] data_type: WGS_PE\n[25-07-2023 12:58:14 UTC] threads: 12\n[25-07-2023 12:58:14 UTC] local_jobs: 4\n[25-07-2023 12:58:14 UTC] strainphlan: False\n[25-07-2023 12:58:14 UTC] keep: False\n[25-07-2023 12:58:14 UTC] project_name: 5bfc066feb92\n[25-07-2023 12:58:14 UTC] inputs_dir: None\n[25-07-2023 12:58:14 UTC] outputs_dir: None\n[25-07-2023 12:58:14 UTC] Results manager initialized. Results registry path: /mnt/EFS/user_uploads/5bfc066feb92/outputs/5bfc066feb92_results_registry.json\n[25-07-2023 12:58:14 UTC] Skipping FASTQ file validation\n[25-07-2023 12:58:14 UTC] Renaming paired end files.\n[25-07-2023 12:58:14 UTC] Inputs directory: /nephele_data/outputs/renamed_inputs/\n[25-07-2023 12:58:14 UTC] Running Whole Metagenome Shotgun Workflow (wmgx).\n[25-07-2023 12:58:19 UTC] run --mount type=bind,source=/mnt/EFS/dbs/biobakery_workflows_databases_3.0.0.a.7,target=/opt/biobakery_workflows_databases --mount type=bind,source=/nephele_data/,target=/nephele_data/ --user www-data biobakery/nephele2:3.0.0.a.7 biobakery_workflows wmgx --input-extension fastq --threads 12 --input /nephele_data/outputs/renamed_inputs/ --output /nephele_data/outputs/ --skip-nothing --local-jobs 4 --taxonomic-profiling-options \"-x mpa_v30_CHOCOPhlAn_201901\" --bypass-strain-profiling\n[25-07-2023 13:38:00 UTC] Create wmgx_vis output directory: /nephele_data/outputs/wmgx_vis\n[25-07-2023 13:38:00 UTC] Checking output files from wmgx workflow that are required by wmgx_vis workflow.\n[25-07-2023 13:38:00 UTC] Running Visualization for Whole Metagenome Shotgun Workflow (wmgx_vis).\n[25-07-2023 13:38:04 UTC] run --mount type=bind,source=/mnt/EFS/dbs/biobakery_workflows_databases_3.0.0.a.7,target=/opt/biobakery_workflows_databases --mount type=bind,source=/nephele_data/,target=/nephele_data/ --user www-data biobakery/nephele2:3.0.0.a.7 biobakery_workflows wmgx_vis --input /nephele_data/outputs/ --project-name '5bfc066feb92' --format html --output /nephele_data/outputs/wmgx_vis --introduction-text \"The data was run through the standard workflow for whole metagenome shotgun sequencing  with the exception of strain profiling (StrainPhlAn).  Details of the pipelines can be found in the &lt;a href=https://github.com/biobakery/biobakery/wiki/biobakery_workflows#2-metagenome-profiling&gt;bioBakery Workflows Tutorial&lt;/a&gt;.\"\n[25-07-2023 13:38:04 UTC] Checking output files from wmgx_vis pipeline.\n[25-07-2023 13:38:04 UTC] Pipeline Error:\n[25-07-2023 13:38:04 UTC] ('/nephele_data/outputs/wmgx_vis/wmgx_report.html does not exist.\\n', 'Job ID Unknown')\n[25-07-2023 13:38:04 UTC] A step in the biobakery workflows may have failed. Check anadama.log files.\n[25-07-2023 13:38:04 UTC] \n[25-07-2023 13:38:04 UTC] Cleaning up intermediate files.\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.trimmed.single.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.trimmed.single.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.trimmed.single.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_hg37dec_v0.1_bowtie2_paired_contam_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_hg37dec_v0.1_bowtie2_unmatched_1_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.repeats.removed.unmatched.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.repeats.removed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_unmatched_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_hg37dec_v0.1_bowtie2_unmatched_2_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.trimmed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.trimmed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.trimmed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_hg37dec_v0.1_bowtie2_paired_contam_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.repeats.removed.unmatched.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_hg37dec_v0.1_bowtie2_paired_contam_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.trimmed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.repeats.removed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_paired_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.repeats.removed.unmatched.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.repeats.removed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_paired_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_hg37dec_v0.1_bowtie2_paired_contam_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_paired_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_hg37dec_v0.1_bowtie2_paired_contam_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_unmatched_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_hg37dec_v0.1_bowtie2_paired_contam_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_hg37dec_v0.1_bowtie2_unmatched_2_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_hg37dec_v0.1_bowtie2_unmatched_1_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.repeats.removed.unmatched.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.trimmed.single.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.trimmed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_unmatched_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.repeats.removed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.repeats.removed.unmatched.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_hg37dec_v0.1_bowtie2_unmatched_1_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_paired_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831.trimmed.single.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.trimmed.single.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_unmatched_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350_unmatched_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_paired_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.repeats.removed.unmatched.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.repeats.removed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_paired_1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22831_hg37dec_v0.1_bowtie2_unmatched_2_contam.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192.repeats.removed.1.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22192_unmatched_2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/kneaddata/main/A22350.trimmed.2.fastq\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/metaphlan/main/A22192_bowtie2.sam\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/metaphlan/main/A22350_bowtie2.sam\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/metaphlan/main/A22831_bowtie2.sam\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/humann/main/A22192_humann_temp\n[25-07-2023 13:38:04 UTC] Removing /nephele_data/outputs/humann/main/A22831_humann_temp\n[25-07-2023 13:38:09 UTC] Removing /nephele_data/outputs/humann/main/A22350_humann_temp\n</code></pre>"},{"location":"EC2_instance_setup/","title":"EC2 instance setup","text":"<p>Using ECS ContainerInsights?</p> <p>This section may not be required for your setup. For instance, if you plan to monitor ECS containers that report the metrics with ECS ContainerInsights.</p> <p>In order to use the tool a <code>CloudWatchAgent</code> process must be running on the EC2 instance to be monitored.</p> <p>Please refer to this page to learn how to install and start the <code>CloudWatchAgent</code> on an EC2 instance.</p>"},{"location":"EC2_instance_setup/#configuration","title":"Configuration","text":"<p><code>CloudWatchAgent</code> is a powerful tool and can be configured to report variety of metrics.</p> <p>Here is an example of the configuration file:</p> cloudwatch_agent_cfg.json<pre><code>{\n\"agent\": {\n\"metrics_collection_interval\": 10\n},\n\"metrics\": {\n\"namespace\": \"ExampleNamespace\",\n\"metrics_collected\": {\n\"mem\": {\n\"measurement\": [\"mem_used\", \"mem_cached\", \"mem_total\"],\n\"metrics_collection_interval\": 1\n}\n},\n\"append_dimensions\": {\n\"InstanceId\": \"${aws:InstanceId}\"\n}\n}\n}\n</code></pre> <p>The above configuration file is used to colect 3 memory metrics every second:</p> <ul> <li><code>mem_used</code></li> <li><code>mem_cached</code></li> <li><code>mem_total</code></li> </ul>"},{"location":"EC2_instance_setup/#ec2-userdata","title":"EC2 userdata","text":"<p>The tool can be configured to be launched automatically by the EC2 instance userdata. Here are the steps to configure the tool to be launched automatically:</p> <ol> <li>Download <code>CloudWatchAgent</code> appropriate for your EC2 instance type; learn more here.</li> <li>Install <code>CloudWatchAgent</code> on the EC2 instance.</li> <li>Create/copy a <code>CloudWatchAgent</code> configuration file.</li> <li>Start the <code>CloudWatchAgent</code> service pointing to the created configuration file.</li> </ol> <p>For a Debian EC2 instance, the steps can be achieved by executing the following commands:</p> ec2_userdata.sh<pre><code>#!/bin/bash\nCLOUDWATCH_CFG_SRC=&lt;path-in-repo&gt;/config.json\nCLOUDWATCH_CFG_FILE=/opt/aws/amazon-cloudwatch-agent/bin/config.json\n\nwget https://s3.amazonaws.com/amazoncloudwatch-agent/debian/amd64/latest/amazon-cloudwatch-agent.deb\ndpkg -i -E ./amazon-cloudwatch-agent.deb\ncp $CLOUDWATCH_CFG_SRC $CLOUDWATCH_CFG_FILE\n/opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl -a fetch-config -m ec2 -s -c file:$CLOUDWATCH_CFG_FILE\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>This project adheres to Semantic Versioning and Keep a Changelog format.</p>"},{"location":"changelog/#020-2023-07-31","title":"[0.2.0] - 2023-07-31","text":""},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>internal improvements and refactoring</li> </ul>"},{"location":"changelog/#012-2022-11-23","title":"[0.1.2] - 2022-11-23","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li><code>AttributeError: module 'datetime' has no attribute 'now'</code></li> </ul>"},{"location":"changelog/#011-2022-11-23","title":"[0.1.1] - 2022-11-23","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li><code>metric_description</code> property to <code>MetricWatcher</code> and <code>MetricWasterSetup</code> classes</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li><code>MetricWatcher.get_ec2_uptime</code> method</li> </ul>"},{"location":"changelog/#010-2022-11-08","title":"[0.1.0] - 2022-11-08","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>presets functionality to improve UX</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>merged <code>--dimension-name</code> and <code>--dimension-value</code> into <code>--dimensions</code> option</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>defaults for <code>--id</code>, <code>-unit</code>, <code>--stat</code> etc. Presets should be used instead</li> <li><code>query_kwargs</code> argument</li> </ul>"},{"location":"changelog/#006-2022-05-03","title":"[0.0.6] - 2022-05-03","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>A possibility to query dimensions other than <code>InstanceId</code> via <code>--dimension-name</code> option.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li><code>-iid/--instance-id</code> option. Use a combination of <code>--dimension-name</code> and <code>--dimension-value</code> from now.</li> </ul>"},{"location":"changelog/#004-2022-04-28","title":"[0.0.4] - 2022-04-28","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>A possibility to specify EC2 query presets for CloudWatch metrics -- <code>query_presets</code> argument</li> <li>A possibility to specify EC2 query key word arguments -- <code>query_kwargs</code> argument</li> </ul>"},{"location":"changelog/#003-2022-04-25","title":"[0.0.3] - 2022-04-25","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added support for log saving to file: <code>cloudwatcher log --save</code></li> </ul>"},{"location":"changelog/#002-2022-04-25","title":"[0.0.2] - 2022-04-25","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Initial release</li> </ul>"},{"location":"docs_development/","title":"Documentation development","text":"<p>The documentation is built from the makrdown files in the <code>/docs</code> directory with static site generator MkDocs.</p>"},{"location":"docs_development/#with-make","title":"With <code>make</code>","text":"<p>Makefile</p> <p>The following commands are encoded in a Makefie in this repository: <code>makefile</code>.</p>"},{"location":"docs_development/#serve","title":"Serve","text":"<p>To serve the documentation locally, you can the <code>serve_docs</code> target:</p> <pre><code>make serve_docs\n</code></pre> <p>The documentation is served on http://localhost:8000/.</p>"},{"location":"docs_development/#build","title":"Build","text":"<p>To build the documentation, you can the <code>build_docs</code> target:</p> <pre><code>make build_docs\n</code></pre> <p>The documentation is built in the <code>/site</code> directory.</p>"},{"location":"docs_development/#deploy","title":"Deploy","text":"<p>To deploy the documentation to GitHub Pages, you can the <code>deploy_docs</code> target:</p> <pre><code>make deploy_docs\n</code></pre> <p>The documentation is deployed to GitHub Pages.</p>"},{"location":"docs_development/#by-hand","title":"By hand","text":"<p>In order to serve the documentation by hand follow the steps below.</p> <p>Note</p> <p>The commands need to be run from the root of the repository, unless stated otherwise.</p> <ol> <li>Install the documentation-related dependancies and the Python package itself with Poetry</li> </ol> <pre><code>poetry install\n</code></pre> <ol> <li>Document the API of the package</li> </ol> <pre><code>lucidoc cloudwatcher --parse rst --outfile docs/API_documentation.md\n</code></pre> <ol> <li>Run the following command in the project root</li> </ol> <pre><code>mkdocs serve\n</code></pre>"},{"location":"docs_development/#deploying-the-documentation","title":"Deploying the documentation","text":"<p>In order to deploy the documentation run the following command:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"features/","title":"Features","text":"<p>The tool can generate multiple outputs, depending on the options specified. Generally, they can be classified as: console output and output files.</p>"},{"location":"features/#console-output","title":"Console output","text":"<p>Always generated.</p>"},{"location":"features/#table","title":"Table","text":"<p>A table printed to the console, which can be used for visual inspection of the metrics collected.</p> <pre><code>\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Time (UTC) \u2503 Value      \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502  19:17:30  \u2502 469.113 MB \u2502\n\u2502  19:17:00  \u2502 1.721 GB   \u2502\n\u2502  19:16:30  \u2502 6.230 GB   \u2502\n\u2502  19:16:00  \u2502 7.428 GB   \u2502\n\u2502  19:15:30  \u2502 2.417 GB   \u2502\n\u2502  19:15:00  \u2502 2.752 GB   \u2502\n\u2502  19:14:30  \u2502 2.836 GB   \u2502\n\u2502  19:14:00  \u2502 1.348 GB   \u2502\n\u2502  19:13:30  \u2502 772.855 MB \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"features/#summary-message","title":"Summary message","text":"<p>A summary message is printed to the console:</p> <pre><code>Max 'memory_usage' is 6.23 GB over 1:03:00 timespan\n</code></pre>"},{"location":"features/#uptime","title":"Uptime","text":"<p>A summary message with the uptime of the instance in seconds. It's either calculated precisely if the instance is running, or estimated based on the reported metrics over at least 15 days. If a longer period of time is desired, please use the <code>--days</code> option.</p> <pre><code>Instance uptime is 72886 seconds\n</code></pre>"},{"location":"features/#output-files","title":"Output files","text":"<p>Generated when <code>--save</code> option is used.</p>"},{"location":"features/#json-with-reponse","title":"JSON with reponse","text":"<p>A JSON file with the response from the AWS API, useful for debugging.</p> {dimension_name}_{dimension_value}_{metric}_response.json<pre><code>{\n\"MetricDataResults\": [\n{\n\"Id\": \"memory_usage\",\n\"Label\": \"mem_used\",\n\"Values\": [\n492003328.0, 492204032.0, 492040192.0, 450666496.0, 429965312.0\n],\n\"Timestamps\": [\n\"2021-11-12 19:19:00+00:00\",\n\"2021-11-12 19:18:30+00:00\",\n\"2021-11-12 19:18:00+00:00\",\n\"2021-11-12 19:12:00+00:00\",\n\"2021-11-12 19:11:30+00:00\"\n],\n\"StatusCode\": \"Complete\"\n}\n],\n\"Messages\": [],\n\"ResponseMetadata\": {\n\"RequestId\": \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\",\n\"HTTPStatusCode\": 200,\n\"HTTPHeaders\": {\n\"x-amzn-requestid\": \"f603ff23-a3d3-43a7-b3b3-65106445a9ed\",\n\"content-type\": \"text/xml\",\n\"content-length\": \"1954\",\n\"date\": \"Fri, 12 Nov 2021 22:05:42 GMT\"\n},\n\"RetryAttempts\": 0\n}\n}\n</code></pre>"},{"location":"features/#json-with-metric-data","title":"JSON with metric data","text":"<p>A JSON file with the raw data, which can be used for further analysis.</p> {dimension_name}_{dimension_value}_{metric}.json<pre><code>{\n\"Label\": \"mem_used\",\n\"Values\": [492003328.0, 492204032.0, 492040192.0, 450666496.0, 429965312.0],\n\"Timestamps\": [\n\"2021-11-12 19:19:00+00:00\",\n\"2021-11-12 19:18:30+00:00\",\n\"2021-11-12 19:18:00+00:00\",\n\"2021-11-12 19:12:00+00:00\",\n\"2021-11-12 19:11:30+00:00\"\n]\n}\n</code></pre>"},{"location":"features/#csv-with-metric-data","title":"CSV with metric data","text":"<p>A CSV file with the raw data, which can be used for further analysis.</p> {dimension_name}_{dimension_value}_{metric}.csv<pre><code>time,value\n2021-11-12 19:19:00+00:00,492003328.0\n2021-11-12 19:18:30+00:00,492204032.0\n2021-11-12 19:18:00+00:00,492040192.0\n2021-11-12 19:12:00+00:00,450666496.0\n2021-11-12 19:11:30+00:00,429965312.0\n</code></pre>"},{"location":"features/#plot-with-metric-data","title":"Plot with metric data","text":"<p>Generated when <code>--plot</code> option used.</p> <p> </p> <code>{dimension_name}_{dimension_value}_{metric}.png</code>"},{"location":"installation/","title":"Installation","text":"<p>The package is distributed and available on PyPI: cloudwatcher. Therefore you can install it using pip:</p> <pre><code>pip install cloudwatcher\n</code></pre>"},{"location":"login_credentials/","title":"Login credentials","text":"<p>The login credentials that determine the AWS account to be used are resolved by <code>boto3</code>, the official Python SDK for AWS, during the <code>boto3.Session.client</code> initialization.</p>"},{"location":"login_credentials/#resolution-order","title":"Resolution order","text":"<p>In general, the credentials are resolved in the following order:</p> <ol> <li> <p>The credentials are read from the environment variables:</p> <ul> <li><code>AWS_ACCESS_KEY_ID</code></li> <li><code>AWS_SECRET_ACCESS_KEY</code></li> </ul> <pre><code>export AWS_ACCESS_KEY_ID=&lt;access_key_id&gt;\nexport AWS_SECRET_ACCESS_KEY=&lt;secret_access_key&gt;\n</code></pre> </li> <li> <p>The credentials are read from <code>[default]</code> section of the <code>~/.aws/credentials</code> file</p> <pre><code>[default]\naws_access_key_id = &lt;access_key_id&gt;\naws_secret_access_key = &lt;secret_access_key&gt;\n</code></pre> </li> </ol>"},{"location":"presets/","title":"Presets","text":"<p>In order to improve the UX when using <code>cloudwatcher metric</code> comamnd. The <code>cloudwatcher</code> package provides a few presets that can be used to query the data reported by <code>CloudWatchAgent</code> within certain systems. Additionally, custom presets can be defined by the user and used in the same way.</p> <p>Presets are JSON-formatted files that provide parameter bundles for <code>MetricWatcher</code> initialization.</p>"},{"location":"presets/#usage","title":"Usage","text":"<p>The presets are used if <code>--preset-name</code> or <code>--preset-path</code> option is provided. The <code>--preset-name</code> option can be used to select one of the built-in presets. The <code>--preset-path</code> option can be used to select a custom preset.</p> <p>Importantly, the settings defined in the preset can be extended or overridden by the user by providing additional arguments to the <code>cloudwatcher metric</code> command, e.g. <code>--dimensions key:value --metric-id test</code>.</p>"},{"location":"presets/#custom-preset-command-example","title":"Custom preset command example","text":"<p>The custom preset can be defined in a JSON file, for example:</p> custom_preset.json<pre><code>{\n\"namespace\": \"MetricNamespace\",\n\"dimensions_list\": [\n{\n\"Name\": \"InstanceId\",\n\"Value\": \"i-0c4d9523c99fbc1da\"\n},\n{\n\"Name\": \"cpu\",\n\"Value\": \"cpu-total\"\n}\n],\n\"metric_name\": \"cpu_usage_user\",\n\"metric_id\": \"my_metric_id\",\n\"metric_unit\": \"Percent\"\n}\n</code></pre> <p>The above preset can be used by passing the <code>--preset-path</code> option:</p> <pre><code>cloudwatcher metric --preset-path custom_preset.json\n</code></pre>"},{"location":"presets/#built-in-preset-command-example","title":"Built-in preset command example","text":"<p>The built-in presets can be used by passing the <code>--preset-name</code> option:</p> <pre><code>cloudwatcher metric --preset-name nepehele_mem\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>There are two modes of operation on the CLI:</p> <ul> <li><code>cloudwatcher metric</code></li> <li><code>cloudwatcher log</code></li> </ul> <pre><code>cloudwatcher --help\n</code></pre> <pre><code>Documentation available at: https://niaid.github.io/cloudwatcher\n\nusage: cloudwatcher [-h] {metric,log} ...\n\nCloudWatch logs and metrics explorer.\n\npositional arguments:\n  {metric,log}\n    metric      Interact with AWS CloudWatch metrics.\n    log         Interact with AWS CloudWatch logs.\n\noptional arguments:\n  -h, --help    show this help message and exit\n</code></pre>"},{"location":"usage/#cloudwatch-metrics-monitoring","title":"CloudWatch metrics monitoring","text":"<p>The tool is highly configurable and can be used in a variety of ways. Naturally, the metrics available to be monitored depend on the configuration of the CloudWatchAgent process.</p> <p>By default the tool will report the <code>mem_used</code> metric starting 24 hours ago until present with granularity/period of 1 minute, expressed in Bytes.</p> <p>Please refer to the usage below for more options:</p> <pre><code>clouwatcher metric --help\n</code></pre> <pre><code>Documentation available at: https://niaid.github.io/cloudwatcher\n\nusage: cloudwatcher metric [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T]\n                           [--save] [-d DIR] [-q Q] [-i ID] [-m N] [-dn N] -dv V [--uptime] [--days D] [-hr H] [-mi M] [-u U] [-s S] [-p P] [--plot]\n                           --namespace N\n\nInteract with AWS CloudWatch metrics.\n\noptional arguments:\n  -h, --help                  show this help message and exit\n  --version                   Print version and exit\n  --debug                     Whether debug mode should be launched (default: False)\n  --save                      Whether to save the results to files in the selected directory (default: False)\n  -d DIR, --dir DIR           Directory to store the results in. Used with `--save` (default: ./)\n  -q Q, --query-json Q        Path to a query JSON file. This is not implemented yet.\n  -i ID, --id ID              The unique identifier to assign to the metric data. Must be of the form '^[a-z][a-zA-Z0-9_]*$'.\n  -m N, --metric N            Name of the metric collected by CloudWatchAgent (default: mem_used)\n  -dn N, --dimension-name N   The name of the dimension to query. (default: InstanceId)\n  -dv V, --dimension-value V  The value of the dimension to filter on.\n  --uptime                    Display the uptime of the instance in seconds. It's either calculated precisely if the instance is still running, or\n                              estimated based on the reported metrics.\n  -u U, --unit U              If you omit Unit then all data that was collected with any unit is returned. If you specify a unit, it acts as a filter\n                              and returns only data that was collected with that unit specified. Use 'Bytes' for memory (default: None)\n  -s S, --stat S              The statistic to apply over the time intervals, e.g. 'Maximum' (default: Maximum)\n  -p P, --period P            The granularity, in seconds, of the returned data points. Choices: 1, 5, 10, 30, 60, or any multiple of 60 (default:\n                              60). It affects the data availability. See the docs 'Usage' section for more details.\n  --plot                      Whether to plot the metric data (default: False)\n  --namespace N               Namespace to monitor the metrics within. This value must match the 'Namespace' value in the CloudWatchAgent config.\n\nAWS CREDENTIALS:\n  Can be ommited if set in environment variables\n\n  --aws-region R              Region to monitor the metrics within. (default: us-east-1)\n  --aws-access-key-id K       AWS Access Key ID to use for authentication\n  --aws-secret-access-key S   AWS Secret Access Key to use for authentication\n  --aws-session-token T       AWS Session Token to use for authentication\n\nMETRIC COLLECTION TIME:\n  The time range to collect metrics from. Uptime will be estimated in the timespan starting at least 15 ago.\n\n  --days D                    How many days to subtract from the current date to determine the metric collection start time (default: 1).\n  -hr H, --hours H            How many hours to subtract from the current time to determine the metric collection start time (default: 0).\n  -mi M, --minutes M          How many minutes to subtract from the current time to determine the metric collection start time (default: 0).\n</code></pre>"},{"location":"usage/#command-example","title":"Command example","text":"<p>This minimal command will query dimesion <code>InstanceId</code> for <code>mem_used</code> in <code>Bytes</code> with period 60s over last 2 days.</p> <pre><code>cloudwatcher metric --dimensions InstanceId:i-0e0165b35c8d648c8 --namespace NepheleNamespaceEC2 --metric mem_used --id mem_used --days 2 --stat Maximum --unit Bytes\n</code></pre>"},{"location":"usage/#notes-on-metrics-availabilty","title":"Notes on metrics availabilty","text":"<p>Amazon CloudWatch retains metric data as follows:</p> <ul> <li>Data points with a period of less than 60 seconds are available for 3 hours.</li> <li>Data points with a period of 60 seconds (1-minute) are available for 15 days.</li> <li>Data points with a period of 300 seconds (5-minute) are available for 63 days.</li> <li>Data points with a period of 3600 seconds (1 hour) are available for 455 days (15 months).</li> </ul> <p>Select your period of interest accordingly. This is crucial as for example if the EC2 instance has stopped over 3 hours ago, selecting a &lt; 60 second period will return an empty reponse.</p>"},{"location":"usage/#using-presets","title":"Using presets","text":"<p>As you can see, the command required to retrieve the metrics is quite long. To make it easier to use, you can create a preset file and use it to query the metrics. Alternatively, you can use one of the built-in presets.</p> <p>List presets with:</p> <pre><code>cloudwatcher metric --preset-list\n</code></pre> <p>Query metrics with preset:</p> <pre><code>cloudwatcher metric --preset &lt;preset_name&gt;\n</code></pre>"},{"location":"usage/#cloudwatch-logs-monitoring","title":"CloudWatch logs monitoring","text":"<pre><code>clouwatcher log --help\n</code></pre> <pre><code>Documentation available at: https://niaid.github.io/cloudwatcher\n\nusage: cloudwatcher log [-h] [--version] [--debug] [--aws-region R] [--aws-access-key-id K] [--aws-secret-access-key S] [--aws-session-token T]\n                        [--save] [-d DIR] -g G -s S\n\nInteract with AWS CloudWatch logs.\n\noptional arguments:\n  -h, --help                 show this help message and exit\n  --version                  Print version and exit\n  --debug                    Whether debug mode should be launched (default: False)\n  --save                     Whether to save the results to files in the selected directory (default: False)\n  -d DIR, --dir DIR          Directory to store the results in. Used with `--save` (default: ./)\n  -g G, --log-group-name G   The log group name to monitor\n  -s S, --log-stream-name S  The log stream name to monitor\n\nAWS CREDENTIALS:\n  Can be ommited if set in environment variables\n\n  --aws-region R             Region to monitor the metrics within. (default: us-east-1)\n  --aws-access-key-id K      AWS Access Key ID to use for authentication\n  --aws-secret-access-key S  AWS Secret Access Key to use for authentication\n  --aws-session-token T      AWS Session Token to use for authentication\n</code></pre>"}]}